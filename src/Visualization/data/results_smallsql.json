{ 
   "summary": {
       "project_name": "Small SQL"
   },

   "directories": [ 	
       "/smallsql/database"	
   ],

   "files": [ 
       {
          "name": "SSPreparedStatement.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Index.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionSoundex.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "IndexNode.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "SSResultSetMetaData.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionLeft.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "JoinScroll.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Database.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionTimestampAdd.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "DateTime.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionRound.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Identity.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionLTrim.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionReturnP1.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "StoreImpl.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "View.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "SSResultSet.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "IndexDescription.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionReturnP1Number.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionSign.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "SQLParser.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Utils.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "TableView.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionTruncate.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "LongTreeList.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionValue.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "CommandDrop.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Money.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionArithmetic.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionConvert.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionRTrim.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "SQLTokenizer.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionTimestampDiff.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunctionRight.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "Table.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "SSStatement.java", 
          "dir": "/smallsql/database"
       },

       {
          "name": "ExpressionFunction.java", 
          "dir": "/smallsql/database"
       }
   ],
   
   "clone_pairs": [ 
       {
           "id": "clone_0",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1156",
               "end_line": "1210",
               "source_code": "                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:\r\n                    rightExpr = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, operation );\r\n                    break;\r\n                case SQLTokenizer.BETWEEN:\r\n                    rightExpr = expression( cmd, ExpressionArithmetic.AND );\r\n                    nextToken( MISSING_AND );\r\n                    Expression rightExpr2 = expression( cmd, level );\r\n                    leftExpr = new ExpressionArithmetic( leftExpr, rightExpr, rightExpr2, operation );\r\n                    break;\r\n                case SQLTokenizer.IN:\r\n            \t\tnextToken(MISSING_PARENTHESIS_L);\r\n                \ttoken = nextToken(MISSING_EXPRESSION);\r\n                \tif(token.value == SQLTokenizer.SELECT){\r\n                \t\tCommandSelect cmdSel = select();\r\n\t\t\t\t\t\tleftExpr = new ExpressionInSelect( con, leftExpr, cmdSel, operation );\r\n\t\t\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n                \t}else{\r\n                \t\tpreviousToken();\r\n                \t\tExpressions list = expressionParenthesisList( cmd );\r\n                \t\tleftExpr = new ExpressionArithmetic( leftExpr, list, operation );\r\n                \t}\r\n                    break;\r\n                case SQLTokenizer.IS:\r\n                \ttoken = nextToken(MISSING_NOT_NULL);\r\n                \tif(token.value == SQLTokenizer.NOT){\r\n                \t\tnextToken(MISSING_NULL);\r\n\t\t\t\t\t\toperation++;\r\n                \t}\r\n                \tleftExpr = new ExpressionArithmetic( leftExpr, operation );\r\n                \tbreak;\r\n                case SQLTokenizer.NOT:\r\n                \ttoken = nextToken(MISSING_BETWEEN_IN);\r\n                \tpreviousToken();\r\n                \tisNot = true;\r\n                \tcontinue;\r\n                default:\r\n                        previousToken();\r\n                        return leftExpr;"
           },

           "clone": {
               "file": "IndexNode.java",
               "start_line": "428",
               "end_line": "441",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tvalue = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tvalue = new Long(input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tvalue = new LongTreeList(input);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tvalue = loadRef( input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.INDEX_CORRUPT, String.valueOf(valueType));"
           }

       },

       {
           "id": "clone_1",

           "clone_type": "type-3",

           "origin": {
               "file": "SSPreparedStatement.java",
               "start_line": "236",
               "end_line": "259",
               "source_code": "\t\tif(batches == null || batches.size() == 0) return new int[0];\r\n\t\tint[] result = new int[batches.size()];\r\n\t\tBatchUpdateException failed = null;\r\n\t\tfor(int b=0; b<batches.size(); b++){\r\n\t\t\ttry{\r\n                checkStatement();\r\n\t\t\t\tExpressionValue[] values = (ExpressionValue[])batches.get(b);\r\n\t\t\t\tfor(int i=0; i<values.length; i++){\r\n\t\t\t\t\t((ExpressionValue)cmd.params.get(i)).set( values[i] );\r\n\t\t\t\t}\r\n\t\t\t\tresult[b] = executeUpdate();\r\n\t\t\t} catch (SQLException ex) {\r\n\t\t\t\tresult[b] = EXECUTE_FAILED;\r\n\t\t\t\tif(failed == null){\r\n\t\t\t\t\tfailed = new BatchUpdateException(ex.getMessage(), ex.getSQLState(), ex.getErrorCode(), result);\r\n\t\t\t\t\tfailed.initCause(ex);\r\n\t\t\t\t}\r\n\t\t\t\tfailed.setNextException(ex);\r\n\t\t\t}\r\n\t\t}\r\n    \tbatches.clear();\r\n    \tif(failed != null)\r\n    \t\tthrow failed;\r\n    \treturn result;"
           },

           "clone": {
               "file": "SSStatement.java",
               "start_line": "262",
               "end_line": "281",
               "source_code": "        if(batches == null)\r\n            return new int[0];\r\n        final int[] result = new int[batches.size()];\r\n        BatchUpdateException failed = null;\r\n        for(int i = 0; i < result.length; i++){\r\n            try{\r\n                result[i] = executeUpdate((String)batches.get(i));\r\n            }catch(SQLException ex){\r\n                result[i] = EXECUTE_FAILED;\r\n                if(failed == null){\r\n                    failed = new BatchUpdateException(ex.getMessage(), ex.getSQLState(), ex.getErrorCode(), result);\r\n                    failed.initCause(ex);\r\n                }\r\n                failed.setNextException(ex);\r\n            }\r\n        }\r\n        batches.clear();\r\n        if(failed != null)\r\n            throw failed;\r\n        return result;"
           }

       },

       {
           "id": "clone_2",

           "clone_type": "type-3",

           "origin": {
               "file": "LongTreeList.java",
               "start_line": "376",
               "end_line": "387",
               "source_code": "\t\t\t\t// there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tloopToEndOfNode(listEnum);"
           },

           "clone": {
               "file": "LongTreeList.java",
               "start_line": "331",
               "end_line": "342",
               "source_code": "\t\t\t\t//there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;\r\n\t\t\t\tfirstNode = true;"
           }

       },

       {
           "id": "clone_3",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "392",
               "end_line": "411",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn new MutableNumeric(getBoolean() ? 1 : 0);\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getIntImpl());\r\n            case SQLTokenizer.BIGINT:\r\n                return new MutableNumeric(getLongImpl());\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return new MutableNumeric(getFloatImpl());\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n                return new MutableNumeric( getDoubleImpl() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getNumericImpl();\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoneyImpl(),4);"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_4",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1155",
               "end_line": "1203",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return (long)(Utils.bytes2double( readBinary() ) * 10000L);\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:\r\n                    return (long)(readFloat() * 10000L);\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)(readDouble() * 10000L);\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return (long)(readNumeric().doubleValue() * 10000L);\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Money.parseMoney( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return (long)(Utils.bytes2double( readLongBinary() ) * 10000L);\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1216",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_5",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "963",
               "end_line": "1015",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (long)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().longValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getLong( ois.readObject().toString(), SQLTokenizer.VARCHAR );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BIGINT\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1216",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_6",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "378",
               "end_line": "382",
               "source_code": "            case ADD: return left.getMoney() + right.getMoney();\r\n            case SUB: return left.getMoney() - right.getMoney();\r\n            case MUL: return left.getMoney() * right.getMoney() / 10000;\r\n            case DIV: return left.getMoney() * 10000 / right.getMoney();\t\t\t\t\t\r\n            case NEGATIVE: return \t\t\t - left.getMoney();"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_7",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "620",
               "end_line": "632",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getDouble() == right.getDouble();\r\n                        case GREATER:   return left.getDouble() >  right.getDouble();\r\n                        case GRE_EQU:   return left.getDouble() >= right.getDouble();\r\n                        case LESSER:    return left.getDouble() <  right.getDouble();\r\n                        case LES_EQU:   return left.getDouble() <= right.getDouble();\r\n                        case UNEQUALS:  return left.getDouble() != right.getDouble();\r\n                        case BETWEEN:\r\n                                        double _left = left.getDouble();\r\n                                        return _left >= right.getDouble() && right2.getDouble() >= _left;\r\n                        default:\r\n                        \treturn getDouble() != 0;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "657",
               "end_line": "668",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;"
           }

       },

       {
           "id": "clone_8",

           "clone_type": "type-3",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "87",
               "end_line": "97",
               "source_code": "\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;"
           },

           "clone": {
               "file": "ExpressionFunctionReturnP1Number.java",
               "start_line": "62",
               "end_line": "75",
               "source_code": "\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new MutableNumeric(getLong());\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoney(), 4);\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tnum.floor();\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new MutableNumeric(getDouble());\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();"
           }

       },

       {
           "id": "clone_9",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "126",
               "end_line": "150",
               "source_code": "\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "545",
               "end_line": "559",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj == Boolean.TRUE) ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).longValue() * 10000;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                return Utils.doubleToMoney(((Number)obj).doubleValue());\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn ((Money)obj).value;\r\n            default: return Money.parseMoney( obj.toString() );"
           }

       },

       {
           "id": "clone_10",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1255",
               "end_line": "1270",
               "source_code": "                            case SQLTokenizer.D: // date escape sequence\r\n                            \texpr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.DATE), SQLTokenizer.DATE );\r\n                            \tbreak;\r\n                            case SQLTokenizer.T: // time escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIME), SQLTokenizer.TIME );\r\n                            \tbreak;\r\n                            case SQLTokenizer.TS: // timestamp escape sequence\r\n                                expr = new ExpressionValue( DateTime.valueOf(para.getName(sql), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP );\r\n                            \tbreak;\r\n                            case SQLTokenizer.FN: // function escape sequence\r\n                            \tnextToken(MISSING_PARENTHESIS_L);\r\n                            \texpr = function(cmd, para, true);\r\n                            \tbreak;\r\n                            case SQLTokenizer.CALL: // call escape sequence\r\n                                throw new java.lang.UnsupportedOperationException(\"call escape sequence\");\r\n                            default: throw new Error();"
           },

           "clone": {
               "file": "IndexNode.java",
               "start_line": "428",
               "end_line": "441",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tvalue = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tvalue = new Long(input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tvalue = new LongTreeList(input);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tvalue = loadRef( input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.INDEX_CORRUPT, String.valueOf(valueType));"
           }

       },

       {
           "id": "clone_11",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "372",
               "end_line": "378",
               "source_code": "    \tint newSize = offset + 4;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);\r\n        page[ offset++ ] = (byte)(value);"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "389",
               "end_line": "399",
               "source_code": "    \tint newSize = offset + 8;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 56);\r\n        page[ offset++ ] = (byte)(value >> 48);\r\n        page[ offset++ ] = (byte)(value >> 40);\r\n        page[ offset++ ] = (byte)(value >> 32);\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);\r\n        page[ offset++ ] = (byte)(value);"
           }

       },

       {
           "id": "clone_12",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionReturnP1.java",
               "start_line": "52",
               "end_line": "91",
               "source_code": "\t        case SQLTokenizer.BIT:\r\n\t        case SQLTokenizer.BOOLEAN:\r\n\t                return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t        case SQLTokenizer.BINARY:\r\n\t        case SQLTokenizer.VARBINARY:\r\n\t                return getBytes();\r\n\t        case SQLTokenizer.TINYINT:\r\n\t        case SQLTokenizer.SMALLINT:\r\n\t        case SQLTokenizer.INT:\r\n\t                return new Integer( getInt() );\r\n\t        case SQLTokenizer.BIGINT:\r\n\t                return new Long( getLong() );\r\n\t        case SQLTokenizer.REAL:\r\n\t                return new Float( getFloat() );\r\n\t        case SQLTokenizer.FLOAT:\r\n\t        case SQLTokenizer.DOUBLE:\r\n\t                return new Double( getDouble() );\r\n\t        case SQLTokenizer.MONEY:\r\n\t        case SQLTokenizer.SMALLMONEY:\r\n\t                return Money.createFromUnscaledValue( getMoney() );\r\n\t        case SQLTokenizer.NUMERIC:\r\n\t        case SQLTokenizer.DECIMAL:\r\n\t                return getNumeric();\r\n\t        case SQLTokenizer.CHAR:\r\n\t        case SQLTokenizer.NCHAR:\r\n\t        case SQLTokenizer.VARCHAR:\r\n\t        case SQLTokenizer.NVARCHAR:\r\n\t        case SQLTokenizer.LONGNVARCHAR:\r\n\t        case SQLTokenizer.LONGVARCHAR:\r\n\t        \t\treturn getString();\r\n\t        case SQLTokenizer.LONGVARBINARY:\r\n\t                return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n\t        case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t                return getBytes();\r\n\t        default: throw createUnspportedDataType(param1.getDataType());"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "478",
               "end_line": "525",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return getBytes();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( getMoney() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return getNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n            \t\treturn getString( left.getString(), right.getString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    Object lObj = left.getObject();\r\n                    //FIXME NullPointerException bei NEGATIVE\r\n                    Object rObj = right.getObject();\r\n                    if(lObj instanceof Number && rObj instanceof Number)\r\n                        return new Double( getDoubleImpl( ((Number)lObj).doubleValue(), ((Number)rObj).doubleValue() ) );\r\n                    else\r\n                        return getString( lObj.toString(), rObj.toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n                    return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return getBytes();\r\n            default: throw createUnspportedDataType();"
           }

       },

       {
           "id": "clone_13",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "161",
               "end_line": "206",
               "source_code": "\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "218",
               "end_line": "255",
               "source_code": "\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);"
           }

       },

       {
           "id": "clone_14",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "637",
               "end_line": "649",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getMoney() == right.getMoney();\r\n                        case GREATER:   return left.getMoney() >  right.getMoney();\r\n                        case GRE_EQU:   return left.getMoney() >= right.getMoney();\r\n                        case LESSER:    return left.getMoney() <  right.getMoney();\r\n                        case LES_EQU:   return left.getMoney() <= right.getMoney();\r\n                        case UNEQUALS:  return left.getMoney() != right.getMoney();\r\n                        case BETWEEN:\r\n                                        long _left = left.getMoney();\r\n                                        return _left >= right.getMoney() && right2.getMoney() >= _left;\r\n                        default:\r\n                        \treturn getMoney() != 0;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "657",
               "end_line": "668",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;"
           }

       },

       {
           "id": "clone_15",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionSign.java",
               "start_line": "51",
               "end_line": "82",
               "source_code": "\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tint intValue = param1.getInt();\r\n\t\t\t\tif(intValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(intValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tlong longValue = param1.getLong();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tlongValue = param1.getMoney();\r\n\t\t\t\tif(longValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(longValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\treturn param1.getNumeric().getSignum();\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tdouble doubleValue = param1.getDouble();\r\n\t\t\t\tif(doubleValue < 0)\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif(doubleValue > 0)\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\treturn 0;\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();"
           },

           "clone": {
               "file": "ExpressionFunctionReturnP1Number.java",
               "start_line": "62",
               "end_line": "75",
               "source_code": "\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new MutableNumeric(getLong());\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoney(), 4);\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tMutableNumeric num = param1.getNumeric();\r\n\t\t\t\tnum.floor();\r\n\t\t\t\treturn num;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn new MutableNumeric(getDouble());\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error();"
           }

       },

       {
           "id": "clone_16",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "105",
               "end_line": "142",
               "source_code": "                case SQLTokenizer.LONGVARBINARY:\r\n                    // is used for storing of LONGVARBINARY and LONGVARCHAR\r\n                    store.page = new byte[(int)filePos + PAGE_CONTROL_SIZE];\r\n                    store.filePos = -1;\r\n                    break;\r\n                case SQLTokenizer.INSERT:\r\n                case SQLTokenizer.CREATE:\r\n                    store.page = new byte[DEFAULT_PAGE_SIZE];\r\n                    break;\r\n                case SQLTokenizer.SELECT:\r\n                case SQLTokenizer.UPDATE:\r\n            \tcase SQLTokenizer.DELETE:\r\n                    if(storePage.page == null){\r\n                        FileChannel raFile = storePage.raFile;\r\n                        synchronized(raFile){\r\n                            if(filePos >= raFile.size() - PAGE_CONTROL_SIZE){\r\n                                return null;\r\n                            }\r\n                            raFile.position(filePos);\r\n                            synchronized(page_control){\r\n                                pageControlBuffer.position(0);\r\n                                raFile.read(pageControlBuffer);\r\n                                store.page = page_control;\r\n                                store.readPageHeader();\r\n                            }\r\n                            store.page = new byte[store.sizeUsed];\r\n                            raFile.position(filePos);\r\n                            ByteBuffer buffer = ByteBuffer.wrap(store.page);\r\n                            raFile.read(buffer);\r\n                        }\r\n                    }else{\r\n                        store.page = storePage.page;\r\n                        store.sharedPageData = true;\r\n                        store.readPageHeader();\r\n                    }\r\n                    store = store.loadUpdatedStore();\r\n                    break;\r\n                default: throw new Error();"
           },

           "clone": {
               "file": "Table.java",
               "start_line": "502",
               "end_line": "559",
               "source_code": "\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();"
           }

       },

       {
           "id": "clone_17",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "672",
               "end_line": "715",
               "source_code": "                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    offset += 3;\r\n                    break;\r\n                default: throw new Error();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "111",
               "end_line": "259",
               "source_code": "\t\t\tcase GROUP_BY:\r\n\t\t\tcase FIRST:\r\n\t\t\t\tif(isEmpty()) set( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase LAST:\r\n\t\t\t\tset( expr.getObject(), expr.getDataType() );\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tif(!expr.isNull()) ((MutableInteger)value).value++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase SUM:\r\n\t\t\t\tif(isEmpty()){\r\n\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else\r\n\t\t\t\tswitch(dataType){\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t((MutableInteger)value).value += expr.getInt();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t((MutableLong)value).value += expr.getLong();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t((MutableFloat)value).value += expr.getFloat();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t((MutableDouble)value).value += expr.getDouble();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\tif(newValue != null)\r\n\t\t\t\t\t\t\t((MutableNumeric)value).add( newValue );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t((Money)value).value += expr.getMoney();\r\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t\r\n\t\t\t\t\tdefault: throw SmallSQLException.create(Language.UNSUPPORTED_TYPE_SUM, SQLTokenizer.getKeyWord(dataType));\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MAX:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.max( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.max( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.max( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.max( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) < 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) < 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.max( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.max( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\t\t// uuid are fixed-len uppercase hex strings and can be correctly \r\n\t\t\t\t\t\t\t// compared with compareTo()\r\n\t\t\t\t\t\t\tString uuidStr = expr.getString();\r\n\t\t\t\t\t\t\tif (uuidStr.compareTo( (String)value) > 0) value = uuidStr;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tString keyword = SQLTokenizer.getKeyWord(dataType);\r\n\t\t\t\t\t\t\tthrow SmallSQLException.create(Language.UNSUPPORTED_TYPE_MAX, keyword);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\t\tif(value == null){\r\n\t\t\t\t\tif(expr.isNull())\r\n\t\t\t\t\t\tdataType = expr.getDataType();\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tinitValue( expr );\r\n\t\t\t\t}else if(!expr.isNull()){\r\n\t\t\t\t\tswitch(dataType){\r\n\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();"
           }

       },

       {
           "id": "clone_18",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "737",
               "end_line": "756",
               "source_code": "            case NEGATIVE:\r\n            case BIT_NOT:\r\n            \treturn left.getDataType();\r\n\t\t\tcase EQUALS:\r\n\t\t\tcase EQUALS_NULL:\r\n\t\t\tcase GREATER:\r\n\t\t\tcase GRE_EQU:\r\n\t\t\tcase LESSER:\r\n\t\t\tcase LES_EQU:\r\n\t\t\tcase UNEQUALS:\r\n\t\t\tcase BETWEEN:\r\n\t\t\tcase OR:\r\n\t\t\tcase AND:\r\n\t\t\tcase NOT:\r\n\t\t\tcase LIKE:\r\n\t\t\tcase ISNULL:\r\n\t\t\tcase ISNOTNULL:\r\n\t\t\t \treturn SQLTokenizer.BOOLEAN;\r\n            default:\r\n            \treturn getDataType(left, right);"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "532",
               "end_line": "540",
               "source_code": "        \tcase OR:    return left.getBoolean() || right.getBoolean();\r\n            case AND:   return left.getBoolean() && right.getBoolean();\r\n            case NOT:   return                      !left.getBoolean();\r\n            case LIKE:  return Utils.like( left.getString(), right.getString());\r\n            case ISNULL:return \t\t\t\t\t\tleft.isNull();\r\n\t\t\tcase ISNOTNULL:\treturn \t\t\t\t\t!left.isNull();\r\n\t\t\tcase IN:\tif(right == null)\r\n\t\t\t\t\t\t\treturn isInList();\r\n\t\t\t\t\t\tbreak;"
           }

       },

       {
           "id": "clone_19",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "663",
               "end_line": "702",
               "source_code": "                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.COMMA:\r\n                    cmdCreate.addColumn( col );\r\n                    return token;\r\n                case SQLTokenizer.DEFAULT:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n\t\t\t\t\tint offset = token.offset + token.length;\r\n                    token = nextToken();\r\n                    if(token != null) offset = token.offset;\r\n\t\t\t\t\tpreviousToken();                    \r\n\t\t\t\t\tExpression expr = expression(cmdCreate, 0);\r\n\t\t\t\t\tSQLToken last = lastToken();\r\n\t\t\t\t\tint length = last.offset + last.length - offset;\r\n\t\t\t\t\tString def = new String( sql, offset, length );\r\n                    col.setDefaultValue( expr, def );\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.IDENTITY:\r\n                    if(defaultWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    col.setAutoIncrement(true);\r\n                    defaultWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NULL:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    //col.setNullable(true); is already default\r\n                    nullableWasSet = true;\r\n                    break;\r\n                case SQLTokenizer.NOT:\r\n                    if(nullableWasSet) throw createSyntaxError( token, MISSING_COMMA_PARENTHESIS );\r\n                    token = nextToken( MISSING_NULL );\r\n                    col.setNullable(false);\r\n                    nullableWasSet = true;\r\n                    break;\r\n\t\t\t\tcase SQLTokenizer.PRIMARY:\r\n\t\t\t\tcase SQLTokenizer.UNIQUE:\r\n\t\t\t\t\tIndexDescription index = index(cmdCreate, token.value, cmdCreate.name, null, colName);\r\n\t\t\t\t\tcmdCreate.addIndex( index );\r\n\t\t\t\t\tbreak;\r\n                default:\r\n                    throw createSyntaxError(token, MISSING_OPTIONS_DATATYPE);"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1846",
               "end_line": "1896",
               "source_code": "                case SQLTokenizer.ON:\r\n                    previousToken();\r\n                    return fromSource;\r\n                case SQLTokenizer.CROSS:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break\r\n                case SQLTokenizer.COMMA:\r\n                    fromSource = new Join( Join.CROSS_JOIN, fromSource, rowSource(cmd, tables, 0), null);\r\n                    break;\r\n                case SQLTokenizer.INNER:\r\n                    nextToken(MISSING_JOIN);\r\n                    //no break;\r\n                case SQLTokenizer.JOIN:\r\n                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:\r\n                \ttoken = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:\r\n                case SQLTokenizer.ESCAPE_R:\r\n                    if(parenthesis == token.value) return fromSource;\r\n                    if(parenthesis == 0){\r\n                    \tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                    }\r\n                    throw createSyntaxError( token, Language.STXADD_FROM_PAR_CLOSE );\r\n                default:\r\n                \tif(isKeyword(token)){\r\n\t\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\t\treturn fromSource;\r\n                \t}\r\n                    if(!fromSource.hasAlias()){\r\n                        fromSource.setAlias( token.getName( sql ) );\r\n                        break;\r\n                    }\r\n                    throw createSyntaxError( token, new int[]{SQLTokenizer.COMMA, SQLTokenizer.GROUP, SQLTokenizer.ORDER, SQLTokenizer.HAVING} );"
           }

       },

       {
           "id": "clone_20",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "461",
               "end_line": "484",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).longValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: \r\n            \tString str = obj.toString();\r\n            \tif(str.indexOf('-') > 0 || str.indexOf(':') > 0)\r\n            \t\treturn DateTime.parse(str);\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Long.parseLong( str );\r\n\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\treturn (long)Double.parseDouble( str );\r\n\t\t\t\t}"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "426",
               "end_line": "450",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );"
           }

       },

       {
           "id": "clone_21",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "587",
               "end_line": "599",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getLong() == right.getLong();\r\n                        case GREATER:   return left.getLong() >  right.getLong();\r\n                        case GRE_EQU:   return left.getLong() >= right.getLong();\r\n                        case LESSER:    return left.getLong() <  right.getLong();\r\n                        case LES_EQU:   return left.getLong() <= right.getLong();\r\n                        case UNEQUALS:  return left.getLong() != right.getLong();\r\n                        case BETWEEN:\r\n                                        long _left = left.getLong();\r\n                                        return _left >= right.getLong() && right2.getLong() >= _left;\r\n                        default:\r\n                        \treturn getLong() != 0;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "657",
               "end_line": "668",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;"
           }

       },

       {
           "id": "clone_22",

           "clone_type": "type-3",

           "origin": {
               "file": "Index.java",
               "start_line": "235",
               "end_line": "287",
               "source_code": "\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, floatToBinarySortOrder( expr.getFloat()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, doubleToBinarySortOrder( expr.getDouble()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getInt(), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, shortToBinarySortOrder( expr.getInt()), isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, intToBinarySortOrder( expr.getInt()), isLastValues, 2 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, longToBinarySortOrder( expr.getLong()), isLastValues, 4 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), false ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, stringToBinarySortOrder( expr.getString(), true ), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, bytesToBinarySortOrder( expr.getBytes()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, expr.getBoolean() ? 2 : 1, isLastValues, 1 );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\tpage = add( page, rowOffset, numericToBinarySortOrder( expr.getNumeric()), isLastValues );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));"
           },

           "clone": {
               "file": "Index.java",
               "start_line": "160",
               "end_line": "213",
               "source_code": "\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\tpage = find( page, floatToBinarySortOrder( expr.getFloat()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tpage = find( page, doubleToBinarySortOrder( expr.getDouble()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tpage = find( page, expr.getInt(), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tpage = find( page, shortToBinarySortOrder( expr.getInt()), 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\tpage = find( page, intToBinarySortOrder( expr.getInt()), 2, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\t\t\tpage = find( page, longToBinarySortOrder( expr.getLong()), 4, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), false ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tpage = find( page, stringToBinarySortOrder( expr.getString(), true ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\t\t\tpage = find( page, bytesToBinarySortOrder( expr.getBytes()), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\t\t\tpage = find( page, expr.getBoolean() ? 2 : 1, 1, nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\tcase SQLTokenizer.DECIMAL:\t\t\t\t\t\t\r\n\t\t\t\t\t\tpage = find( page, numericToBinarySortOrder( expr.getNumeric() ), nodeList );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault: \r\n\t\t\t\t\t\t//TODO more data types\r\n\t\t\t\t\t\tthrow new Error(String.valueOf(expr.getDataType()));"
           }

       },

       {
           "id": "clone_23",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "572",
               "end_line": "597",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return new MutableNumeric( (obj == Boolean.TRUE) ? 1 : 0);\r\n            case SQLTokenizer.INT:\r\n                return new MutableNumeric( ((Number)obj).intValue() );\r\n            case SQLTokenizer.BIGINT:\r\n                return new MutableNumeric( ((Number)obj).longValue() );\r\n            case SQLTokenizer.REAL:\r\n                float fValue = ((Number)obj).floatValue();\r\n                if(Float.isInfinite(fValue) || Float.isNaN(fValue))\r\n                    return null;\r\n                return new MutableNumeric( fValue );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                double dValue = ((Number)obj).doubleValue();\r\n                if(Double.isInfinite(dValue) || Double.isNaN(dValue))\r\n                    return null;\r\n                return new MutableNumeric( dValue );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn new MutableNumeric( ((Money)obj).value, 4 );\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n\t\t\t\tif(obj instanceof MutableNumeric)\r\n\t\t\t\t\treturn (MutableNumeric)obj;\r\n\t\t\t\treturn new MutableNumeric( (BigDecimal)obj );\r\n            default: return new MutableNumeric( obj.toString() );"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "426",
               "end_line": "450",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n                return ((Number)obj).intValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn (int)((DateTime)obj).getTimeMillis();\r\n            default:\r\n\t\t\t\tString str = obj.toString().trim();\r\n\t\t\t\ttry{\r\n\t\t\t\t\treturn Integer.parseInt( str );\r\n\t\t\t\t}catch(Throwable th){/* A NumberFormatException can occur if it a floating point number */}\r\n\t\t\t\treturn (int)Double.parseDouble( str );"
           }

       },

       {
           "id": "clone_24",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "350",
               "end_line": "367",
               "source_code": "\t\t\t\tcase SQLTokenizer.TOP:\r\n\t\t\t\t\ttoken = nextToken(MISSING_EXPRESSION);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tint maxRows = Integer.parseInt(token.getName(sql));\r\n\t\t\t\t\t\tselCmd.setMaxRows(maxRows);\r\n\t\t\t\t\t}catch(NumberFormatException e){\r\n\t\t\t\t\t\tthrow createSyntaxError(token, Language.STXADD_NOT_NUMBER, token.getName(sql));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.ALL:\r\n\t\t\t\t\tselCmd.setDistinct(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.DISTINCT:\r\n\t\t\t\t\tselCmd.setDistinct(true);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tpreviousToken();\r\n\t\t\t\t\tbreak Switch;"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1909",
               "end_line": "1920",
               "source_code": "                case SQLTokenizer.WHERE:\r\n                    where( cmd );\r\n                    break;\r\n                case SQLTokenizer.GROUP:\r\n                    group( cmd );\r\n                    break;\r\n                case SQLTokenizer.HAVING:\r\n                    having( cmd );\r\n                    break;\r\n                default:\r\n                \tpreviousToken();\r\n                    return;"
           }

       },

       {
           "id": "clone_25",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1473",
               "end_line": "1524",
               "source_code": "                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                    int count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count;  // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:\r\n                    count = readByte();\r\n\t\t\t\t\toffset += 2;\r\n\t\t\t\t\tif(!isNull) offset += count*4;\r\n                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    count = readShort() & 0xFFFF;\r\n                    if(!isNull) offset += count << 1; // not use += directly because readShort change the offset\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                default: throw new Error(String.valueOf( dataTypes[i] ) );"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "218",
               "end_line": "255",
               "source_code": "\t\t\t\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\t\t((MutableInteger)value).value = Math.min( ((MutableInteger)value).value, expr.getInt());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\t\t((MutableLong)value).value = Math.min( ((MutableLong)value).value, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\t\t((MutableFloat)value).value = Math.min( ((MutableFloat)value).value, expr.getFloat());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\t\t((MutableDouble)value).value = Math.min( ((MutableDouble)value).value, expr.getDouble());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();\r\n\t\t\t\t\t\t\tif(String.CASE_INSENSITIVE_ORDER.compare( (String)value, str ) > 0) //cast needed for Compiler 1.5\r\n\t\t\t\t\t\t\t\tvalue = str;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\t\tMutableNumeric newValue = expr.getNumeric();\r\n\t\t\t\t\t\t\tif(((MutableNumeric)value).compareTo( newValue ) > 0)\r\n\t\t\t\t\t\t\t\tvalue = newValue;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\t\t\t((Money)value).value = Math.min( ((Money)value).value, expr.getMoney());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\t\t((DateTime)value).time = Math.min( ((DateTime)value).time, expr.getLong());\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault: throw new Error(\"\"+dataType);"
           }

       },

       {
           "id": "clone_26",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionRTrim.java",
               "start_line": "53",
               "end_line": "61",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int length = bytes.length;\r\n        while(length>0 && bytes[length-1]==0){\r\n            length--;\r\n        }\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;"
           },

           "clone": {
               "file": "ExpressionFunctionLeft.java",
               "start_line": "53",
               "end_line": "60",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;"
           }

       },

       {
           "id": "clone_27",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1043",
               "end_line": "1048",
               "source_code": "                case SQLTokenizer.PARENTHESIS_R:\r\n                    return list;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1110",
               "end_line": "1115",
               "source_code": "                case SQLTokenizer.PARENTHESIS_R:\r\n                    break Loop;\r\n                case SQLTokenizer.COMMA:\r\n                    continue;\r\n                default:\r\n                    throw new Error();"
           }

       },

       {
           "id": "clone_28",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "704",
               "end_line": "713",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= Utils.compareBytes( leftBytes, right2.getBytes() );"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "682",
               "end_line": "692",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:\r\n                                        return comp >= 0 && 0 >= String.CASE_INSENSITIVE_ORDER.compare( leftStr, right2.getString() );\r\n                        case ADD:       return Utils.string2boolean(leftStr + rightStr);"
           }

       },

       {
           "id": "clone_29",

           "clone_type": "type-3",

           "origin": {
               "file": "JoinScroll.java",
               "start_line": "135",
               "end_line": "139",
               "source_code": "                                case Join.LEFT_JOIN:\r\n                                case Join.FULL_JOIN:\r\n                                    isOuterValid = false;\r\n                                    right.nullRow();\r\n                                    return true;"
           },

           "clone": {
               "file": "JoinScroll.java",
               "start_line": "98",
               "end_line": "103",
               "source_code": "                            case Join.LEFT_JOIN:\r\n                            case Join.FULL_JOIN:\r\n                                isOuterValid = false;\r\n                                isBeforeFirst = false;\r\n                                right.nullRow();\r\n                                return true;"
           }

       },

       {
           "id": "clone_30",

           "clone_type": "type-3",

           "origin": {
               "file": "CommandDrop.java",
               "start_line": "49",
               "end_line": "73",
               "source_code": "            case SQLTokenizer.DATABASE:\r\n                if(name.startsWith(\"file:\"))\r\n                    name = name.substring(5);\r\n                File dir = new File( name );\r\n                if(!dir.isDirectory() || \r\n                   !new File( dir, Utils.MASTER_FILENAME ).exists())\r\n               \t\t\tthrow SmallSQLException.create(Language.DB_NONEXISTENT, name);\r\n                File files[] = dir.listFiles();\r\n                if(files != null)\r\n\t                for(int i=0; i<files.length; i++){\r\n\t                    files[i].delete();\r\n\t                }\r\n                dir.delete();\r\n                break;\r\n            case SQLTokenizer.TABLE:\r\n                Database.dropTable( con, catalog, name );\r\n                break;\r\n            case SQLTokenizer.VIEW:\r\n\t\t\t\tDatabase.dropView( con, catalog, name );\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n                throw new java.lang.UnsupportedOperationException();\r\n            default:\r\n                throw new Error();"
           },

           "clone": {
               "file": "Table.java",
               "start_line": "502",
               "end_line": "559",
               "source_code": "\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();"
           }

       },

       {
           "id": "clone_31",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionRight.java",
               "start_line": "53",
               "end_line": "60",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, bytes.length -length, b, 0, length);\r\n\t\treturn b;"
           },

           "clone": {
               "file": "ExpressionFunctionLeft.java",
               "start_line": "53",
               "end_line": "60",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;"
           }

       },

       {
           "id": "clone_32",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "312",
               "end_line": "329",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return (float)getDoubleImpl();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_33",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "272",
               "end_line": "303",
               "source_code": "\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\tvalue = new MutableInteger(expr.getInt());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\tvalue = new MutableLong(expr.getLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\tvalue = new MutableFloat(expr.getFloat());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\tvalue = new MutableDouble(expr.getDouble());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\tvalue = Money.createFromUnscaledValue(expr.getMoney());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\tvalue = new MutableNumeric(expr.getNumeric());\r\n\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\tvalue = new DateTime(expr.getLong(), dataType);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\t// is used for MAX and MIN\r\n\t\t\t\tvalue = expr.getObject();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "572",
               "end_line": "597",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return new MutableNumeric( (obj == Boolean.TRUE) ? 1 : 0);\r\n            case SQLTokenizer.INT:\r\n                return new MutableNumeric( ((Number)obj).intValue() );\r\n            case SQLTokenizer.BIGINT:\r\n                return new MutableNumeric( ((Number)obj).longValue() );\r\n            case SQLTokenizer.REAL:\r\n                float fValue = ((Number)obj).floatValue();\r\n                if(Float.isInfinite(fValue) || Float.isNaN(fValue))\r\n                    return null;\r\n                return new MutableNumeric( fValue );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                double dValue = ((Number)obj).doubleValue();\r\n                if(Double.isInfinite(dValue) || Double.isNaN(dValue))\r\n                    return null;\r\n                return new MutableNumeric( dValue );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            \treturn new MutableNumeric( ((Money)obj).value, 4 );\r\n            case SQLTokenizer.DECIMAL:\r\n            case SQLTokenizer.NUMERIC:\r\n\t\t\t\tif(obj instanceof MutableNumeric)\r\n\t\t\t\t\treturn (MutableNumeric)obj;\r\n\t\t\t\treturn new MutableNumeric( (BigDecimal)obj );\r\n            default: return new MutableNumeric( obj.toString() );"
           }

       },

       {
           "id": "clone_34",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "352",
               "end_line": "370",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return Utils.doubleToMoney( getFloatImpl() );\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return Utils.doubleToMoney( getDoubleImpl() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn getMoneyImpl();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_35",

           "clone_type": "type-3",

           "origin": {
               "file": "Table.java",
               "start_line": "384",
               "end_line": "399",
               "source_code": "                    // first check if there is any lock before creating a table lock\r\n                    if(locks.size() > 0 || locksInsert.size() > 0){\r\n                        return null;\r\n                    }\r\n                    if(serializeConnections.size() > 0){\r\n                        Iterator values = locks.values().iterator();\r\n                        while(values.hasNext()){\r\n                            TableStorePage lock = (TableStorePage)values.next();\r\n                            if(lock.con != con) return null;\r\n                        }\r\n                    }\r\n                    tabLockConnection = con;\r\n                    tabLockCount++;\r\n                    TableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n                    lock.rollback();\r\n                    return lock;"
           },

           "clone": {
               "file": "Table.java",
               "start_line": "357",
               "end_line": "381",
               "source_code": "\t\t\t\t\t\t// first check if another connection has a lock before creating a table lock\r\n\t\t\t\t\t\tif(locks.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\t//the first StorePage in the linked list must be ever TableStorePageInsert\r\n\t\t\t\t\t\t\tTableStorePageInsert lock = (TableStorePageInsert)locksInsert.get(i);\r\n\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(serializeConnections.size() > 0){\r\n\t\t\t\t\t\t\tIterator values = locks.values().iterator();\r\n\t\t\t\t\t\t\twhile(values.hasNext()){\r\n\t\t\t\t\t\t\t\tTableStorePage lock = (TableStorePage)values.next();\r\n\t\t\t\t\t\t\t\tif(lock.con != con) return null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttabLockConnection = con;\r\n\t\t\t\t\t\ttabLockCount++;\r\n\t\t\t\t\t\tTableStorePage lock = new TableStorePage(con, this, LOCK_TAB, page);\r\n\t\t\t\t\t\tcon.add(lock);\r\n\t\t\t\t\t\treturn lock;"
           }

       },

       {
           "id": "clone_36",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "897",
               "end_line": "950",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (int)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n            \t\tlong longValue = readLong() / 10000;\r\n            \t\treturn Utils.money2int(longValue);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().intValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ExpressionValue.getInt(ois.readObject().toString(), SQLTokenizer.VARCHAR);\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn (int)readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"INT\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1216",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_37",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1278",
               "end_line": "1331",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n                    return Utils.getInteger( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return Utils.getInteger( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return Utils.getInteger(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue(readLong());\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME );\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE );\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1344",
               "end_line": "1398",
               "source_code": "            case SQLTokenizer.BIT:\r\n                    return readBoolean() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return String.valueOf( readBoolean() );\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2hex( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return String.valueOf( readInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return String.valueOf( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue( readLong() ).toString();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( readInt() ).toString();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toString();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject().toString();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2hex( readLongBinary() );\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME ).toString();\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE ).toString();\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_38",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionTimestampDiff.java",
               "start_line": "93",
               "end_line": "123",
               "source_code": "\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() - param1.getLong());\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn (int)(param2.getLong() /1000 - param1.getLong() /1000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn (int)(param2.getLong() /60000 - param1.getLong() /60000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn (int)(param2.getLong() /3600000 - param1.getLong() /3600000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn (int)(param2.getLong() /86400000 - param1.getLong() /86400000);\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\tlong day2 = param2.getLong() /86400000;\r\n\t\t\t\tlong day1 = param1.getLong() /86400000;\r\n\t\t\t\t// the 1. Jan 1970 is a Thursday --> 3\r\n\t\t\t\treturn (int)((day2 + 3) / 7 - (day1 + 3) / 7);\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 12 + details2.month) - (details1.year * 12 + details1.month);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn (details2.year * 4 + details2.month / 3) - (details1.year * 4 + details1.month / 3);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tDateTime.Details details1 = new DateTime.Details(param1.getLong());\r\n\t\t\t\treturn details2.year - details1.year;\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();"
           },

           "clone": {
               "file": "ExpressionFunctionTimestampAdd.java",
               "start_line": "74",
               "end_line": "101",
               "source_code": "\t\t\tcase SQLTokenizer.SQL_TSI_FRAC_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong();\r\n\t\t\tcase SQLTokenizer.SQL_TSI_SECOND:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 1000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_MINUTE:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 60000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_HOUR:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 3600000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_DAY:\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 86400000;\r\n\t\t\tcase SQLTokenizer.SQL_TSI_WEEK:{\r\n\t\t\t\treturn param2.getLong() + param1.getLong() * 604800000;\r\n\t\t\t}case SQLTokenizer.SQL_TSI_MONTH:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_QUARTER:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.month += param1.getLong() * 3;\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tcase SQLTokenizer.SQL_TSI_YEAR:{\r\n\t\t\t\tDateTime.Details details2 = new DateTime.Details(param2.getLong());\r\n\t\t\t\tdetails2.year += param1.getLong();\r\n\t\t\t\treturn DateTime.calcMillis(details2);\r\n\t\t\t}\r\n\t\t\tdefault: throw new Error();"
           }

       },

       {
           "id": "clone_39",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "207",
               "end_line": "213",
               "source_code": "            case ADD:       return left.getInt() + right.getInt();\r\n            case SUB:       return left.getInt() - right.getInt();\r\n            case MUL:       return left.getInt() * right.getInt();\r\n            case DIV:       return left.getInt() / right.getInt();\r\n            case NEGATIVE:  return               - left.getInt();\r\n            case MOD:\t\treturn left.getInt() % right.getInt();\r\n            case BIT_NOT:   return               ~ left.getInt();"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_40",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "419",
               "end_line": "469",
               "source_code": "            case ADD: \r\n            \t{\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n            \t\tnum.add( right.getNumeric() );\r\n            \t\treturn num;\r\n            \t}\r\n            case SUB:\r\n\t\t\t\t{\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n\t\t\t\t\tnum.sub( right.getNumeric() );\r\n\t\t\t\t\treturn num;\r\n\t\t\t\t}\r\n            case MUL: \r\n            \tif(getDataType(right.getDataType(), SQLTokenizer.INT) == SQLTokenizer.INT){\r\n            \t\tMutableNumeric num = left.getNumeric();\r\n            \t\tnum.mul(right.getInt());\r\n            \t\treturn num;\r\n            \t}else\r\n            \tif(getDataType(left.getDataType(), SQLTokenizer.INT) == SQLTokenizer.INT){\r\n\t\t\t\t\tMutableNumeric num = right.getNumeric();\r\n\t\t\t\t\tnum.mul(left.getInt());\r\n\t\t\t\t\treturn num;\r\n            \t}else{\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n\t\t\t\t\tnum.mul( right.getNumeric() );\r\n\t\t\t\t\treturn num;\r\n            \t}\r\n            case DIV:\r\n            \t{\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n            \t\tif(getDataType(right.getDataType(), SQLTokenizer.INT) == SQLTokenizer.INT)\r\n            \t\t\tnum.div( right.getInt() );\r\n            \t\telse\r\n            \t\t\tnum.div( right.getNumeric() ); \r\n            \t\treturn num;\r\n            \t}\r\n            case NEGATIVE:\r\n            \t{\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n\t\t\t\t\tnum.setSignum(-num.getSignum());\r\n\t\t\t\t\treturn num;\r\n            \t}\r\n            case MOD:\r\n\t\t\t\t{\r\n\t\t\t\t\tif(getDataType(getDataType(), SQLTokenizer.INT) == SQLTokenizer.INT)\r\n\t\t\t\t\t\treturn new MutableNumeric(getInt());\r\n\t\t\t\t\tMutableNumeric num = left.getNumeric();\r\n\t\t\t\t\tnum.mod( right.getNumeric() );\r\n\t\t\t\t\treturn num;\r\n\t\t\t\t}\r\n            default:    throw createUnspportedConversion( SQLTokenizer.NUMERIC );"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_41",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1028",
               "end_line": "1080",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return (float)readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / (float)10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / (float)10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().floatValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Float.parseFloat( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1216",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_42",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionTruncate.java",
               "start_line": "46",
               "end_line": "67",
               "source_code": "\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n        value -= value % 1; //modulo also work with values larger long\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;"
           },

           "clone": {
               "file": "ExpressionFunctionRound.java",
               "start_line": "46",
               "end_line": "67",
               "source_code": "\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}\r\n\t\tvalue = Math.rint( value );\r\n\t\tif(places > 0){\r\n\t\t\tvalue /= factor;\r\n\t\t}else{\r\n\t\t\tvalue *= factor;\r\n\t\t}\r\n\t\treturn value;"
           }

       },

       {
           "id": "clone_43",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunction.java",
               "start_line": "74",
               "end_line": "85",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tparam1 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tparam2 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tparam3 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tparam4 = param;\r\n\t\t\t\tbreak;"
           },

           "clone": {
               "file": "IndexNode.java",
               "start_line": "428",
               "end_line": "441",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tvalue = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tvalue = new Long(input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tvalue = new LongTreeList(input);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tvalue = loadRef( input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.INDEX_CORRUPT, String.valueOf(valueType));"
           }

       },

       {
           "id": "clone_44",

           "clone_type": "type-3",

           "origin": {
               "file": "TableView.java",
               "start_line": "81",
               "end_line": "104",
               "source_code": "\t\t\tString fileName = Utils.createTableViewFileName( database, name );\r\n\t\t\tFile file = new File( fileName );\r\n\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_MISSING, name);\r\n\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();\r\n\t\t\tswitch(magic){\r\n\t\t\t\tcase MAGIC_TABLE:\r\n\t\t\t\tcase MAGIC_VIEW:\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_FILE_INVALID, fileName);\r\n\t\t\t}\r\n\t\t\tif(version > TABLE_VIEW_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOONEW, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(version < TABLE_VIEW_OLD_VERSION)\r\n\t\t\t\tthrow SmallSQLException.create(Language.FILE_TOOOLD, new Object[] { new Integer(version), fileName });\r\n\t\t\tif(magic == MAGIC_TABLE)\r\n\t\t\t\treturn new Table( database, con, name, raFile, raFile.position(), version);\r\n\t\t\t\treturn new View ( con, name, raFile, raFile.position());"
           },

           "clone": {
               "file": "IndexDescription.java",
               "start_line": "170",
               "end_line": "185",
               "source_code": "            File file = getFile( database, name );\r\n            if(!file.exists())\r\n                throw SmallSQLException.create(Language.INDEX_MISSING, name);\r\n            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();\r\n            if(magic != MAGIC_INDEX){\r\n                throw SmallSQLException.create(Language.INDEX_FILE_INVALID, file.getName());\r\n            }\r\n            if(version > INDEX_VERSION){\r\n            \tObject[] params = { new Integer(version), file.getName() };\r\n                throw SmallSQLException.create(Language.FILE_TOONEW, params);\r\n            }"
           }

       },

       {
           "id": "clone_45",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "917",
               "end_line": "924",
               "source_code": "            case SQLTokenizer.DATABASE:\r\n            case SQLTokenizer.TABLE:\r\n            case SQLTokenizer.VIEW:\r\n            case SQLTokenizer.INDEX:\r\n            case SQLTokenizer.PROCEDURE:\r\n            \treturn new CommandDrop( con.log, catalog, name, tokenType.value);\r\n            default:\r\n                throw createSyntaxError( tokenType, COMMANDS_DROP );"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "548",
               "end_line": "567",
               "source_code": "                case SQLTokenizer.DATABASE:\r\n                    return createDatabase();\r\n                case SQLTokenizer.TABLE:\r\n                    return createTable();\r\n                case SQLTokenizer.VIEW:\r\n                    return createView();\r\n                case SQLTokenizer.INDEX:\r\n                    return createIndex(false);\r\n                case SQLTokenizer.PROCEDURE:\r\n                    return createProcedure();\r\n                case SQLTokenizer.UNIQUE:\r\n                    do{\r\n                        token = nextToken(COMMANDS_CREATE_UNIQUE);\r\n                    }while(token.value == SQLTokenizer.INDEX);\r\n                    return createIndex(true);\r\n                case SQLTokenizer.NONCLUSTERED:\r\n                case SQLTokenizer.CLUSTERED:\r\n                    continue;\r\n                default:\r\n                    throw createSyntaxError( token, COMMANDS_CREATE );"
           }

       },

       {
           "id": "clone_46",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "603",
               "end_line": "615",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getFloat() == right.getFloat();\r\n                        case GREATER:   return left.getFloat() >  right.getFloat();\r\n                        case GRE_EQU:   return left.getFloat() >= right.getFloat();\r\n                        case LESSER:    return left.getFloat() <  right.getFloat();\r\n                        case LES_EQU:   return left.getFloat() <= right.getFloat();\r\n                        case UNEQUALS:  return left.getFloat() != right.getFloat();\r\n                        case BETWEEN:\r\n                                        float _left = left.getFloat();\r\n                                        return _left >= right.getFloat() && right2.getFloat() >= _left;\r\n                        default:\r\n                        \treturn getFloat() != 0;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "657",
               "end_line": "668",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;"
           }

       },

       {
           "id": "clone_47",

           "clone_type": "type-3",

           "origin": {
               "file": "Database.java",
               "start_line": "512",
               "end_line": "544",
               "source_code": "\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tShort type = Utils.getShort( DatabaseMetaData.tableIndexOther );\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\tObject[] row = new Object[13];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\trow[3] = Boolean.valueOf(!index.isUnique());//NON_UNIQUE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//INDEX_QUALIFIER\r\n\t\t\t\t\trow[5] = index.getName();\t\t//INDEX_NAME\r\n\t\t\t\t\trow[6] = type;\t\t\t\t\t//TYPE\r\n\t\t\t\t\trow[7] = Utils.getShort(c+1);\t//ORDINAL_POSITION\r\n\t\t\t\t\trow[8] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//ASC_OR_DESC\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//CARDINALITY\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//PAGES\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//FILTER_CONDITION\r\n\t\t\t\t\trows.add(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;"
           },

           "clone": {
               "file": "Database.java",
               "start_line": "481",
               "end_line": "507",
               "source_code": "\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isPrimary()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tObject[] row = new Object[6];\r\n\t\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\t\trow[3] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getShort(c+1);\t//KEY_SEQ\r\n\t\t\t\t\t\trow[5] = index.getName();\t\t//PK_NAME\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;"
           }

       },

       {
           "id": "clone_48",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "567",
               "end_line": "579",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return left.getInt() == right.getInt();\r\n                        case GREATER:   return left.getInt() >  right.getInt();\r\n                        case GRE_EQU:   return left.getInt() >= right.getInt();\r\n                        case LESSER:    return left.getInt() <  right.getInt();\r\n                        case LES_EQU:   return left.getInt() <= right.getInt();\r\n                        case UNEQUALS:  return left.getInt() != right.getInt();\r\n                        case BETWEEN:\r\n                                        int _left = left.getInt();\r\n                                        return _left >= right.getInt() && right2.getInt() >= _left;\r\n                        default:\r\n                        \treturn getInt() != 0;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "657",
               "end_line": "668",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n\t\t\t\t\t\tcase EQUALS:    return comp == 0;\r\n\t\t\t\t\t\tcase GREATER:   return comp >  0;\r\n\t\t\t\t\t\tcase GRE_EQU:   return comp >= 0;\r\n\t\t\t\t\t\tcase LESSER:    return comp <  0;\r\n\t\t\t\t\t\tcase LES_EQU:   return comp <= 0;\r\n\t\t\t\t\t\tcase UNEQUALS:  return comp != 0;\r\n\t\t\t\t\t\tcase BETWEEN:\r\n\t\t\t\t\t\t\t\t\t\treturn comp >= 0 && 0 >= left.getNumeric().compareTo( right2.getNumeric() );\r\n                        default:\r\n                        \treturn getNumeric().getSignum() != 0;"
           }

       },

       {
           "id": "clone_49",

           "clone_type": "type-3",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1130",
               "end_line": "1144",
               "source_code": "            case SQLTokenizer.NOT:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NOT      / 10), ExpressionArithmetic.NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.MINUS:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.NEGATIVE / 10), ExpressionArithmetic.NEGATIVE);\r\n            \tbreak;\r\n            case SQLTokenizer.TILDE:\r\n            \tleftExpr =  new ExpressionArithmetic( expression( cmd, ExpressionArithmetic.BIT_NOT  / 10), ExpressionArithmetic.BIT_NOT);\r\n            \tbreak;\r\n            case SQLTokenizer.PARENTHESIS_L:\r\n                leftExpr = expression( cmd, 0);\r\n                token = nextToken(MISSING_PARENTHESIS_R);\r\n                break;\r\n            default:\r\n                leftExpr = expressionSingle( cmd, token);"
           },

           "clone": {
               "file": "IndexNode.java",
               "start_line": "428",
               "end_line": "441",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tvalue = null;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tvalue = new Long(input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tvalue = new LongTreeList(input);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tvalue = loadRef( input.readLong());\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.INDEX_CORRUPT, String.valueOf(valueType));"
           }

       },

       {
           "id": "clone_50",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionFunctionLTrim.java",
               "start_line": "53",
               "end_line": "63",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int start = 0;\r\n        int length = bytes.length;\r\n        while(start<length && bytes[start]==0){\r\n            start++;\r\n        }\r\n        length -= start; \r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, start, b, 0, length);\r\n\t\treturn b;"
           },

           "clone": {
               "file": "ExpressionFunctionRTrim.java",
               "start_line": "53",
               "end_line": "61",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n        int length = bytes.length;\r\n        while(length>0 && bytes[length-1]==0){\r\n            length--;\r\n        }\r\n\t\tbyte[] b = new byte[length];\r\n\t\tSystem.arraycopy(bytes, 0, b, 0, length);\r\n\t\treturn b;"
           }

       },

       {
           "id": "clone_51",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "59",
               "end_line": "73",
               "source_code": "\t\t\tcase GROUP_BY:\r\n\t\t\tcase SUM:\r\n\t\t\tcase FIRST:\r\n\t\t\tcase LAST:\r\n\t\t\t\tclear();\r\n\t\t\t\tbreak;\r\n\t\t\tcase MIN:\r\n\t\t\tcase MAX:\r\n\t\t\t\t// set value to null\r\n\t\t\t\tbreak;\r\n\t\t\tcase COUNT:\r\n\t\t\t\tvalue = new MutableInteger(0);\r\n\t\t\t\tdataType = SQLTokenizer.INT;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault: throw new Error();"
           },

           "clone": {
               "file": "Table.java",
               "start_line": "502",
               "end_line": "559",
               "source_code": "\t\t\t\t\tcase LOCK_INSERT:\r\n\t\t\t\t\t\tfor(int i=0; i<locksInsert.size(); i++){\r\n\t\t\t\t\t\t\tprev = lock = (TableStorePage)locksInsert.get(i);\r\n\t\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t\t//remove lock\r\n\t\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t\t// the first lock is the only lock in the list\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.remove(i--);\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t// only the first lock of the list is remove\r\n\t\t\t\t\t\t\t\t\t\t\tlocksInsert.set( i, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// a lock in the mid or end is removed\r\n\t\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_READ:\r\n\t\t\t\t\tcase LOCK_WRITE:\r\n\t\t\t\t\t\tLong pageKey = new Long(fileOffset); //TODO performance\r\n\t\t\t\t\t\tlock = (TableStorePage)locks.get( pageKey );\r\n\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\twhile(lock != null){\r\n\t\t\t\t\t\t\tif(lock == storePage){\r\n\t\t\t\t\t\t\t\t//lock entfernen\r\n\t\t\t\t\t\t\t\tif(lock == prev){\r\n\t\t\t\t\t\t\t\t\tif(lock.nextLock == null){\r\n\t\t\t\t\t\t\t\t\t\t// erste und einzige Lock in Liste\r\n\t\t\t\t\t\t\t\t\t\tlocks.remove(pageKey);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// the first lock in the list is removed\r\n\t\t\t\t\t\t\t\t\t\tlocks.put( pageKey, lock.nextLock );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t// a lock in the middle or end of the list is removed\r\n\t\t\t\t\t\t\t\t\tprev.nextLock = lock.nextLock;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tprev = lock;\r\n\t\t\t\t\t\t\tlock = lock.nextLock;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// a run through can occur if a lock was step high and the type does not compare\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase LOCK_TAB:\r\n\t\t\t\t\t\tassert storePage.con == tabLockConnection : \"Internal Error with TabLock\";\r\n\t\t\t\t\t\tif(--tabLockCount == 0) tabLockConnection = null;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error();"
           }

       },

       {
           "id": "clone_52",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "249",
               "end_line": "255",
               "source_code": "            case ADD: return left.getLong() + right.getLong();\r\n            case SUB: return left.getLong() - right.getLong();\r\n            case MUL: return left.getLong() * right.getLong();\r\n            case DIV: return left.getLong() / right.getLong();\r\n            case NEGATIVE:  return          - left.getLong();\r\n            case MOD:\t\treturn left.getLong() % right.getLong();\r\n            case BIT_NOT:   return          ~ right.getInt();"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_53",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "830",
               "end_line": "884",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean();\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().getSignum() != 0;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Utils.string2boolean( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                return false;\r\n\t\t\tdefault: \r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"BOOLEAN\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1344",
               "end_line": "1398",
               "source_code": "            case SQLTokenizer.BIT:\r\n                    return readBoolean() ? \"1\" : \"0\";\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return String.valueOf( readBoolean() );\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2hex( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:\r\n                    return String.valueOf( readInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return String.valueOf( readDouble() );\r\n            case SQLTokenizer.MONEY:\r\n                    return Money.createFromUnscaledValue( readLong() ).toString();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( readInt() ).toString();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().toString();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return ois.readObject().toString();\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2hex( readLongBinary() );\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    return new DateTime( readTimestamp(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.TIME:\r\n                    return new DateTime( readTime(), SQLTokenizer.TIME ).toString();\r\n            case SQLTokenizer.DATE:\r\n                    return new DateTime( readDate(), SQLTokenizer.DATE ).toString();\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    return new DateTime( readSmallDateTime(), SQLTokenizer.TIMESTAMP ).toString();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return Utils.bytes2unique( page, this.offset);\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_54",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "337",
               "end_line": "342",
               "source_code": "            case ADD: return left.getFloat() + right.getFloat();\r\n            case SUB: return left.getFloat() - right.getFloat();\r\n            case MUL: return left.getFloat() * right.getFloat();\r\n            case DIV: return left.getFloat() / right.getFloat();\r\n            case NEGATIVE:  return           - left.getFloat();\r\n            case MOD:\t\treturn left.getFloat() % right.getFloat();"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_55",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "495",
               "end_line": "509",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).floatValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Float.parseFloat( obj.toString() );"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "520",
               "end_line": "532",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue();\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default: return Double.parseDouble( obj.toString() );"
           }

       },

       {
           "id": "clone_56",

           "clone_type": "type-3",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1093",
               "end_line": "1145",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return readDouble();\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric().doubleValue();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return Double.parseDouble( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1216",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? new MutableNumeric(1) : new MutableNumeric(0);\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return new MutableNumeric(Utils.bytes2double( readBinary() ));\r\n            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return new MutableNumeric( readInt(), 4);\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);\r\n                    return new MutableNumeric( ois.readObject().toString() );\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return new MutableNumeric( Utils.bytes2double( readLongBinary() ) );\r\n            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_57",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "265",
               "end_line": "282",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getDoubleImpl();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_58",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "179",
               "end_line": "199",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return (int)getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (int)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n            \t// FIXME: bug! if get returns a number outside of\r\n            \t// integer interval, it's not rounded to max/min, \r\n            \t// instead it returns a wrong value\r\n                return (int)getDoubleImpl();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_59",

           "clone_type": "type-3",

           "origin": {
               "file": "Database.java",
               "start_line": "445",
               "end_line": "476",
               "source_code": "\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tif(index.isUnique()){\r\n\t\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\t\tString columnName = columns.get(c);\r\n\t\t\t\t\t\tColumn column = tab.findColumn(columnName);\r\n\t\t\t\t\t\tObject[] row = new Object[8];\r\n\t\t\t\t\t\trow[0] = Utils.getShort(DatabaseMetaData.bestRowSession);//SCOPE\r\n\t\t\t\t\t\trow[1] = columnName;\t\t\t//COLUMN_NAME\r\n\t\t\t\t\t\tfinal int dataType = column.getDataType();\r\n\t\t\t\t\t\trow[2] = Utils.getInteger(dataType);//DATA_TYPE\r\n\t\t\t\t\t\trow[3] = SQLTokenizer.getKeyWord(dataType);//TYPE_NAME\r\n\t\t\t\t\t\trow[4] = Utils.getInteger(column.getPrecision());\t//COLUMN_SIZE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t//BUFFER_LENGTH\r\n\t\t\t\t\t\trow[6] = Utils.getShort(column.getScale());\t\t//DECIMAL_DIGITS\r\n\t\t\t\t\t\trow[7] = Utils.getShort(DatabaseMetaData.bestRowNotPseudo);//PSEUDO_COLUMN\r\n\t\t\t\t\t\trows.add(row);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;"
           },

           "clone": {
               "file": "Database.java",
               "start_line": "512",
               "end_line": "544",
               "source_code": "\t\tList rows = new ArrayList();\r\n\t\tStrings tables = getTables(table);\r\n\t\tShort type = Utils.getShort( DatabaseMetaData.tableIndexOther );\r\n\t\tfor(int t=0; t<tables.size(); t++){\r\n    \t\tString tableName = tables.get(t);\r\n    \t\tTableView tab = getTableView( con, tableName);\r\n\t\t\tif(!(tab instanceof Table)) continue;\r\n\t\t\tIndexDescriptions indexes = ((Table)tab).indexes;\r\n\t\t\tfor(int i=0; i<indexes.size(); i++){\r\n\t\t\t\tIndexDescription index = indexes.get(i);\r\n\t\t\t\tStrings columns = index.getColumns();\r\n\t\t\t\tfor(int c=0; c<columns.size(); c++){\r\n\t\t\t\t\tObject[] row = new Object[13];\r\n\t\t\t\t\trow[0] = getName(); \t\t\t//TABLE_CAT\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//TABLE_SCHEM\r\n\t\t\t\t\trow[2] = tableName;\t\t\t\t//TABLE_NAME\r\n\t\t\t\t\trow[3] = Boolean.valueOf(!index.isUnique());//NON_UNIQUE\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//INDEX_QUALIFIER\r\n\t\t\t\t\trow[5] = index.getName();\t\t//INDEX_NAME\r\n\t\t\t\t\trow[6] = type;\t\t\t\t\t//TYPE\r\n\t\t\t\t\trow[7] = Utils.getShort(c+1);\t//ORDINAL_POSITION\r\n\t\t\t\t\trow[8] = columns.get(c);\t\t//COLUMN_NAME\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//ASC_OR_DESC\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//CARDINALITY\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//PAGES\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//FILTER_CONDITION\r\n\t\t\t\t\trows.add(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n    \t}\r\n\t\tObject[][] result = new Object[rows.size()][];\r\n\t\trows.toArray(result);\r\n\t\treturn result;"
           }

       },

       {
           "id": "clone_60",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "223",
               "end_line": "240",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (long)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return (long)getDoubleImpl();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "403",
               "end_line": "415",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj.equals(Boolean.TRUE));\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n                return ((Number)obj).intValue() != 0;\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n                return ((Number)obj).doubleValue() != 0;\r\n            default: return Utils.string2boolean( obj.toString() );"
           }

       },

       {
           "id": "clone_61",

           "clone_type": "type-3",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "297",
               "end_line": "302",
               "source_code": "            case ADD: return lVal + rVal;\r\n            case SUB: return lVal - rVal;\r\n            case MUL: return lVal * rVal;\r\n            case DIV: return lVal / rVal;\r\n            case NEGATIVE: return - rVal;\r\n            case MOD:\t\treturn lVal % rVal;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "767",
               "end_line": "777",
               "source_code": "\t\t\t\t\tcase ADD:\r\n\t\t\t\t\tcase SUB:\r\n\t\t\t\t\t\treturn Math.max(left.getScale(), right.getScale());\r\n\t\t\t\t\tcase MUL:\r\n\t\t\t\t\t\treturn left.getScale() + right.getScale();\r\n\t\t\t\t\tcase DIV:\r\n\t\t\t\t\t\treturn Math.max(left.getScale()+5, right.getScale()+4);\r\n\t\t\t\t\tcase NEGATIVE:\r\n\t\t\t\t\t\treturn left.getScale();\r\n\t\t\t\t\tcase MOD:\r\n\t\t\t\t\t\treturn 0;"
           }

       },

       {
           "id": "clone_62",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "312",
               "end_line": "328",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "265",
               "end_line": "281",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           }

       },

       {
           "id": "clone_63",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionFunctionReturnP1.java",
               "start_line": "82",
               "end_line": "91",
               "source_code": "\t        case SQLTokenizer.LONGVARBINARY:\r\n\t                return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n\t        case SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t                return getBytes();\r\n\t        default:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "516",
               "end_line": "525",
               "source_code": "            case SQLTokenizer.LONGVARBINARY:\r\n                    return getBytes();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    return getBytes();\r\n            default:"
           }

       },

       {
           "id": "clone_64",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionFunctionRight.java",
               "start_line": "53",
               "end_line": "58",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];"
           },

           "clone": {
               "file": "ExpressionFunctionLeft.java",
               "start_line": "53",
               "end_line": "58",
               "source_code": "\t\tif(isNull()) return null;\r\n\t\tbyte[] bytes = param1.getBytes();\r\n\t\tint length = param2.getInt();\r\n\t\tif(bytes.length <= length) return bytes;\r\n\r\n\t\tbyte[] b = new byte[length];"
           }

       },

       {
           "id": "clone_65",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "567",
               "end_line": "577",
               "source_code": "\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "553",
               "end_line": "563",
               "source_code": "\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);"
           }

       },

       {
           "id": "clone_66",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "559",
               "end_line": "564",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "464",
               "end_line": "469",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_67",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "520",
               "end_line": "524",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "495",
               "end_line": "499",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_68",

           "clone_type": "type-1",

           "origin": {
               "file": "Index.java",
               "start_line": "259",
               "end_line": "263",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:"
           },

           "clone": {
               "file": "Index.java",
               "start_line": "184",
               "end_line": "188",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\tcase SQLTokenizer.LONGNVARCHAR:"
           }

       },

       {
           "id": "clone_69",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "232",
               "end_line": "236",
               "source_code": "\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "175",
               "end_line": "179",
               "source_code": "\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\t\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\t\tString str = expr.getString();"
           }

       },

       {
           "id": "clone_70",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "385",
               "end_line": "389",
               "source_code": "\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "378",
               "end_line": "382",
               "source_code": "\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_71",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1093",
               "end_line": "1097",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1028",
               "end_line": "1032",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:"
           }

       },

       {
           "id": "clone_72",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1473",
               "end_line": "1478",
               "source_code": "                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "672",
               "end_line": "677",
               "source_code": "                case SQLTokenizer.BIT:\r\n                case SQLTokenizer.BOOLEAN:\r\n                case SQLTokenizer.TINYINT:\r\n                    offset++;\r\n                    break;\r\n                case SQLTokenizer.SMALLINT:"
           }

       },

       {
           "id": "clone_73",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionFunctionReturnP1.java",
               "start_line": "52",
               "end_line": "80",
               "source_code": "\t        case SQLTokenizer.BIT:\r\n\t        case SQLTokenizer.BOOLEAN:\r\n\t                return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n\t        case SQLTokenizer.BINARY:\r\n\t        case SQLTokenizer.VARBINARY:\r\n\t                return getBytes();\r\n\t        case SQLTokenizer.TINYINT:\r\n\t        case SQLTokenizer.SMALLINT:\r\n\t        case SQLTokenizer.INT:\r\n\t                return new Integer( getInt() );\r\n\t        case SQLTokenizer.BIGINT:\r\n\t                return new Long( getLong() );\r\n\t        case SQLTokenizer.REAL:\r\n\t                return new Float( getFloat() );\r\n\t        case SQLTokenizer.FLOAT:\r\n\t        case SQLTokenizer.DOUBLE:\r\n\t                return new Double( getDouble() );\r\n\t        case SQLTokenizer.MONEY:\r\n\t        case SQLTokenizer.SMALLMONEY:\r\n\t                return Money.createFromUnscaledValue( getMoney() );\r\n\t        case SQLTokenizer.NUMERIC:\r\n\t        case SQLTokenizer.DECIMAL:\r\n\t                return getNumeric();\r\n\t        case SQLTokenizer.CHAR:\r\n\t        case SQLTokenizer.NCHAR:\r\n\t        case SQLTokenizer.VARCHAR:\r\n\t        case SQLTokenizer.NVARCHAR:\r\n\t        case SQLTokenizer.LONGNVARCHAR:\r\n\t        case SQLTokenizer.LONGVARCHAR:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "478",
               "end_line": "506",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return getBytes();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( getMoney() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return getNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:"
           }

       },

       {
           "id": "clone_74",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionFunctionTruncate.java",
               "start_line": "46",
               "end_line": "60",
               "source_code": "\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"
           },

           "clone": {
               "file": "ExpressionFunctionRound.java",
               "start_line": "46",
               "end_line": "60",
               "source_code": "\t\tif(isNull()) return 0;\r\n\t\tfinal int places = param2.getInt();\r\n\t\tdouble value = param1.getDouble();\r\n\t\tlong factor = 1;\r\n\t\tif(places > 0){\r\n\t\t\tfor(int i=0; i<places; i++){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue *= factor;\r\n\t\t}else{\r\n\t\t\tfor(int i=0; i>places; i--){\r\n\t\t\t\tfactor *= 10;\r\n\t\t\t}\r\n\t\t\tvalue /= factor;\r\n\t\t}"
           }

       },

       {
           "id": "clone_75",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "619",
               "end_line": "627",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "532",
               "end_line": "540",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_76",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "461",
               "end_line": "467",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "426",
               "end_line": "432",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:"
           }

       },

       {
           "id": "clone_77",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1479",
               "end_line": "1502",
               "source_code": "                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "684",
               "end_line": "707",
               "source_code": "                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;"
           }

       },

       {
           "id": "clone_78",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1136",
               "end_line": "1144",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1071",
               "end_line": "1079",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:"
           }

       },

       {
           "id": "clone_79",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "704",
               "end_line": "712",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "682",
               "end_line": "690",
               "source_code": "\t\t\t\t\t\tcase IN:\r\n\t\t\t\t\t\tcase EQUALS_NULL:\r\n                        case EQUALS:    return comp == 0;\r\n                        case GREATER:   return comp >  0;\r\n                        case GRE_EQU:   return comp >= 0;\r\n                        case LESSER:    return comp <  0;\r\n                        case LES_EQU:   return comp <= 0;\r\n                        case UNEQUALS:  return comp != 0;\r\n                        case BETWEEN:"
           }

       },

       {
           "id": "clone_80",

           "clone_type": "type-1",

           "origin": {
               "file": "LongTreeList.java",
               "start_line": "376",
               "end_line": "386",
               "source_code": "\t\t\t\t// there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;"
           },

           "clone": {
               "file": "LongTreeList.java",
               "start_line": "331",
               "end_line": "341",
               "source_code": "\t\t\t\t//there are more entries in this node\r\n\t\t\t\tresult |= (((long)nextEntry) << shift);\r\n\t\t\t\tif(listEnum.stack>=3){\r\n\t\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\tlistEnum.offsetStack[listEnum.stack] = offset+pointerSize;\r\n\t\t\t\toffset = getPointer();\r\n\t\t\t\tshift -= 16;\r\n\t\t\t\tlistEnum.stack++;\r\n\t\t\t\tlistEnum.resultStack[listEnum.stack] = result;"
           }

       },

       {
           "id": "clone_81",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "601",
               "end_line": "612",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "475",
               "end_line": "486",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_82",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "614",
               "end_line": "618",
               "source_code": "\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "391",
               "end_line": "395",
               "source_code": "\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           }

       },

       {
           "id": "clone_83",

           "clone_type": "type-1",

           "origin": {
               "file": "TableView.java",
               "start_line": "85",
               "end_line": "90",
               "source_code": "\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();"
           },

           "clone": {
               "file": "IndexDescription.java",
               "start_line": "173",
               "end_line": "178",
               "source_code": "            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();"
           }

       },

       {
           "id": "clone_84",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "589",
               "end_line": "596",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "573",
               "end_line": "580",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_85",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "510",
               "end_line": "514",
               "source_code": "\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "503",
               "end_line": "507",
               "source_code": "\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_86",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "294",
               "end_line": "298",
               "source_code": "\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "248",
               "end_line": "252",
               "source_code": "\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\tcase SQLTokenizer.TIME:"
           }

       },

       {
           "id": "clone_87",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "527",
               "end_line": "532",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "504",
               "end_line": "509",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn ((DateTime)obj).getTimeMillis();\r\n            default:"
           }

       },

       {
           "id": "clone_88",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "455",
               "end_line": "459",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "447",
               "end_line": "451",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');"
           }

       },

       {
           "id": "clone_89",

           "clone_type": "type-1",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "174",
               "end_line": "178",
               "source_code": "\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "131",
               "end_line": "135",
               "source_code": "\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_90",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "472",
               "end_line": "480",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "351",
               "end_line": "359",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);"
           }

       },

       {
           "id": "clone_91",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1301",
               "end_line": "1307",
               "source_code": "            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1239",
               "end_line": "1245",
               "source_code": "            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:"
           }

       },

       {
           "id": "clone_92",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "583",
               "end_line": "587",
               "source_code": "\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "567",
               "end_line": "571",
               "source_code": "\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);"
           }

       },

       {
           "id": "clone_93",

           "clone_type": "type-1",

           "origin": {
               "file": "DateTime.java",
               "start_line": "598",
               "end_line": "603",
               "source_code": "\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "527",
               "end_line": "532",
               "source_code": "\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');"
           }

       },

       {
           "id": "clone_94",

           "clone_type": "type-1",

           "origin": {
               "file": "Index.java",
               "start_line": "269",
               "end_line": "274",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:"
           },

           "clone": {
               "file": "Index.java",
               "start_line": "195",
               "end_line": "200",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:"
           }

       },

       {
           "id": "clone_95",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1371",
               "end_line": "1383",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1304",
               "end_line": "1316",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n                    ByteArrayInputStream bais = new ByteArrayInputStream(readLongBinary());\r\n                    ObjectInputStream ois = new ObjectInputStream(bais);"
           }

       },

       {
           "id": "clone_96",

           "clone_type": "type-1",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "786",
               "end_line": "791",
               "source_code": "\t        case OR:\r\n\t        case AND:\r\n\t        case NOT:\r\n\t        case LIKE:\r\n\t        case ISNULL:\r\n\t\t\tcase ISNOTNULL:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "748",
               "end_line": "753",
               "source_code": "\t\t\tcase OR:\r\n\t\t\tcase AND:\r\n\t\t\tcase NOT:\r\n\t\t\tcase LIKE:\r\n\t\t\tcase ISNULL:\r\n\t\t\tcase ISNOTNULL:"
           }

       },

       {
           "id": "clone_97",

           "clone_type": "type-1",

           "origin": {
               "file": "Index.java",
               "start_line": "250",
               "end_line": "257",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:"
           },

           "clone": {
               "file": "Index.java",
               "start_line": "175",
               "end_line": "182",
               "source_code": "\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\t\tcase SQLTokenizer.SMALLMONEY:"
           }

       },

       {
           "id": "clone_98",

           "clone_type": "type-1",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1099",
               "end_line": "1110",
               "source_code": "            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1034",
               "end_line": "1045",
               "source_code": "            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_99",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1125",
               "end_line": "1129",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1120",
               "end_line": "1124",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_100",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "791",
               "end_line": "796",
               "source_code": "                    break;\r\n            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "785",
               "end_line": "790",
               "source_code": "                    break;\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );"
           }

       },

       {
           "id": "clone_101",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "470",
               "end_line": "480",
               "source_code": "\t\t\tcase 9:\r\n\t\t\tcase 109: // mon dd yyyy hh:mi:ss:mmmAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "349",
               "end_line": "359",
               "source_code": "\t\t\tcase 0:\r\n\t\t\tcase 100: // mon dd yyyy hh:miAM (oder PM)\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);"
           }

       },

       {
           "id": "clone_102",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "579",
               "end_line": "623",
               "source_code": "        addKeyWord( \"BOOLEAN\",      BOOLEAN);\r\n        addKeyWord( \"BINARY\",       BINARY);\r\n        addKeyWord( \"VARBINARY\",    VARBINARY);\r\n\t\taddKeyWord( \"RAW\",          RAW); // alias for Oracle RAW and LONG RAW\r\n\t\taddKeyWord( \"IMAGE\",        LONGVARBINARY); // alias for MS SQL Server data type IMAGE\r\n        addKeyWord( \"LONGVARBINARY\",LONGVARBINARY);\r\n        addKeyWord( \"BLOB\",         BLOB);\r\n        addKeyWord( \"BYTE\",         TINYINT);\r\n        addKeyWord( \"TINYINT\",      TINYINT);\r\n        addKeyWord( \"SMALLINT\",     SMALLINT);\r\n\t\taddKeyWord( \"INTEGER\",      INT);\r\n        addKeyWord( \"INT\",          INT);\r\n        addKeyWord( \"SERIAL\",       COUNTER); //alias for MySQL and PostgreSQL\r\n        addKeyWord( \"COUNTER\",      COUNTER);\r\n        addKeyWord( \"BIGINT\",       BIGINT);\r\n        addKeyWord( \"SMALLMONEY\",   SMALLMONEY);\r\n        addKeyWord( \"MONEY\",        MONEY);\r\n\t\taddKeyWord( \"NUMBER\",       DECIMAL);\r\n\t\taddKeyWord( \"VARNUM\",       DECIMAL);\r\n\t\taddKeyWord( \"DECIMAL\",      DECIMAL);\r\n        addKeyWord( \"NUMERIC\",      NUMERIC);\r\n        addKeyWord( \"REAL\",         REAL);\r\n        addKeyWord( \"FLOAT\",        FLOAT);\r\n        addKeyWord( \"DOUBLE\",       DOUBLE);\r\n        addKeyWord( \"DATE\",         DATE);\r\n        addKeyWord( \"TIME\",         TIME);\r\n        addKeyWord( \"DATETIME\",     TIMESTAMP); // alias for MS SQL Server data type DATETIME\r\n        addKeyWord( \"TIMESTAMP\",    TIMESTAMP);\r\n        addKeyWord( \"SMALLDATETIME\",SMALLDATETIME);\r\n        addKeyWord( \"CHARACTER\",    CHAR); // alias for CHAR\r\n        addKeyWord( \"CHAR\",         CHAR);\r\n        addKeyWord( \"NCHAR\",        NCHAR);\r\n        addKeyWord( \"VARCHAR2\",     VARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"VARCHAR\",      VARCHAR);\r\n        addKeyWord( \"NVARCHAR2\",    NVARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"NVARCHAR\",     NVARCHAR);\r\n\t\taddKeyWord( \"SYSNAME\",      SYSNAME);\r\n        addKeyWord( \"TEXT\",         LONGVARCHAR);\r\n        addKeyWord( \"LONGVARCHAR\",  LONGVARCHAR);\r\n        addKeyWord( \"NTEXT\",        LONGNVARCHAR);\r\n        addKeyWord( \"LONGNVARCHAR\", LONGNVARCHAR);\r\n        addKeyWord( \"LONG\",         LONG); // alias for Oracle LONG and LONG RAW\r\n        addKeyWord( \"CLOB\",         CLOB);\r\n        addKeyWord( \"NCLOB\",        NCLOB);\r\n        addKeyWord( \"UNIQUEIDENTIFIER\",UNIQUEIDENTIFIER);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "488",
               "end_line": "536",
               "source_code": "        addKeyWord( \"VALUES\",   VALUES);\r\n        addKeyWord( \"AS\",       AS);\r\n        addKeyWord( \"DEFAULT\",  DEFAULT);\r\n        addKeyWord( \"AUTO_INCREMENT\", IDENTITY); // alias for IDENTITY; alias must set first so that key is in the hashtable and not the alias\r\n        addKeyWord( \"IDENTITY\", IDENTITY);\r\n        addKeyWord( \"INNER\",    INNER);\r\n        addKeyWord( \"JOIN\",     JOIN);\r\n        addKeyWord( \"ON\",       ON);\r\n        addKeyWord( \"OUTER\",    OUTER);\r\n        addKeyWord( \"FULL\",     FULL);\r\n        addKeyWord( \"CROSS\",    CROSS);\r\n\t\taddKeyWord( \"USE\",      USE);\r\n\t\taddKeyWord( \"TOP\",      TOP);\r\n\t\taddKeyWord( \"ADD\",      ADD);\r\n        addKeyWord( \"LIMIT\",    LIMIT);\r\n\r\n        addKeyWord( \"DATABASE\", DATABASE);\r\n        addKeyWord( \"TABLE\",    TABLE);\r\n        addKeyWord( \"VIEW\",     VIEW);\r\n        addKeyWord( \"INDEX\",    INDEX);\r\n        addKeyWord( \"PROCEDURE\",PROCEDURE);\r\n\r\n        addKeyWord( \"TRANSACTION\",  TRANSACTION);\r\n        addKeyWord( \"ISOLATION\",    ISOLATION);\r\n        addKeyWord( \"LEVEL\",        LEVEL);\r\n        addKeyWord( \"READ\",         READ);\r\n        addKeyWord( \"COMMITTED\",    COMMITTED);\r\n        addKeyWord( \"UNCOMMITTED\",  UNCOMMITTED);\r\n        addKeyWord( \"REPEATABLE\",   REPEATABLE);\r\n        addKeyWord( \"SERIALIZABLE\", SERIALIZABLE);\r\n        \r\n\t\taddKeyWord( \"CONSTRAINT\", \tCONSTRAINT);\r\n\t\taddKeyWord( \"PRIMARY\",    \tPRIMARY);\r\n\t\taddKeyWord( \"FOREIGN\",     \tFOREIGN);\r\n\t\taddKeyWord( \"KEY\",    \t\tKEY);\r\n\t\taddKeyWord( \"UNIQUE\",\t\tUNIQUE);\r\n\t\taddKeyWord( \"CLUSTERED\",  \tCLUSTERED);\r\n\t\taddKeyWord( \"NONCLUSTERED\", NONCLUSTERED);\r\n\t\taddKeyWord( \"REFERENCES\",   REFERENCES);\r\n\r\n\t\taddKeyWord( \"UNION\", \t\tUNION);\r\n\t\taddKeyWord( \"ALL\",   \t\tALL);\r\n\t\taddKeyWord( \"DISTINCT\",   \tDISTINCT);\r\n\t\taddKeyWord( \"CASE\",   \t\tCASE);\r\n\t\taddKeyWord( \"WHEN\",   \t\tWHEN);\r\n\t\taddKeyWord( \"THEN\",   \t\tTHEN);\r\n\t\taddKeyWord( \"ELSE\",   \t\tELSE);\r\n\t\taddKeyWord( \"END\",   \t\tEND);\r\n\t\taddKeyWord( \"SWITCH\", \t\tSWITCH);"
           }

       },

       {
           "id": "clone_103",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1158",
               "end_line": "1170",
               "source_code": "                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "276",
               "end_line": "288",
               "source_code": "    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:"
           }

       },

       {
           "id": "clone_104",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "943",
               "end_line": "947",
               "source_code": "\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn (int)readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "909",
               "end_line": "913",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_105",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "272",
               "end_line": "277",
               "source_code": "            case Types.BIGINT:\r\n                    return \"java.lang.Long\";\r\n            case Types.DECIMAL:\r\n            case Types.NUMERIC:\r\n                    return \"java.math.BigDecimal\";\r\n            case Types.REAL:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "261",
               "end_line": "266",
               "source_code": "            case Types.INTEGER:\r\n                    return \"java.lang.Integer\";\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                    return \"java.lang.Boolean\";\r\n            case Types.BINARY:"
           }

       },

       {
           "id": "clone_106",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "973",
               "end_line": "980",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (long)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "228",
               "end_line": "235",
               "source_code": "            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (long)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_107",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1222",
               "end_line": "1228",
               "source_code": "            case SQLTokenizer.TINYINT:\r\n                    return new MutableNumeric(readUnsignedByte());\r\n            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "486",
               "end_line": "492",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_108",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "580",
               "end_line": "624",
               "source_code": "        addKeyWord( \"BINARY\",       BINARY);\r\n        addKeyWord( \"VARBINARY\",    VARBINARY);\r\n\t\taddKeyWord( \"RAW\",          RAW); // alias for Oracle RAW and LONG RAW\r\n\t\taddKeyWord( \"IMAGE\",        LONGVARBINARY); // alias for MS SQL Server data type IMAGE\r\n        addKeyWord( \"LONGVARBINARY\",LONGVARBINARY);\r\n        addKeyWord( \"BLOB\",         BLOB);\r\n        addKeyWord( \"BYTE\",         TINYINT);\r\n        addKeyWord( \"TINYINT\",      TINYINT);\r\n        addKeyWord( \"SMALLINT\",     SMALLINT);\r\n\t\taddKeyWord( \"INTEGER\",      INT);\r\n        addKeyWord( \"INT\",          INT);\r\n        addKeyWord( \"SERIAL\",       COUNTER); //alias for MySQL and PostgreSQL\r\n        addKeyWord( \"COUNTER\",      COUNTER);\r\n        addKeyWord( \"BIGINT\",       BIGINT);\r\n        addKeyWord( \"SMALLMONEY\",   SMALLMONEY);\r\n        addKeyWord( \"MONEY\",        MONEY);\r\n\t\taddKeyWord( \"NUMBER\",       DECIMAL);\r\n\t\taddKeyWord( \"VARNUM\",       DECIMAL);\r\n\t\taddKeyWord( \"DECIMAL\",      DECIMAL);\r\n        addKeyWord( \"NUMERIC\",      NUMERIC);\r\n        addKeyWord( \"REAL\",         REAL);\r\n        addKeyWord( \"FLOAT\",        FLOAT);\r\n        addKeyWord( \"DOUBLE\",       DOUBLE);\r\n        addKeyWord( \"DATE\",         DATE);\r\n        addKeyWord( \"TIME\",         TIME);\r\n        addKeyWord( \"DATETIME\",     TIMESTAMP); // alias for MS SQL Server data type DATETIME\r\n        addKeyWord( \"TIMESTAMP\",    TIMESTAMP);\r\n        addKeyWord( \"SMALLDATETIME\",SMALLDATETIME);\r\n        addKeyWord( \"CHARACTER\",    CHAR); // alias for CHAR\r\n        addKeyWord( \"CHAR\",         CHAR);\r\n        addKeyWord( \"NCHAR\",        NCHAR);\r\n        addKeyWord( \"VARCHAR2\",     VARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"VARCHAR\",      VARCHAR);\r\n        addKeyWord( \"NVARCHAR2\",    NVARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"NVARCHAR\",     NVARCHAR);\r\n\t\taddKeyWord( \"SYSNAME\",      SYSNAME);\r\n        addKeyWord( \"TEXT\",         LONGVARCHAR);\r\n        addKeyWord( \"LONGVARCHAR\",  LONGVARCHAR);\r\n        addKeyWord( \"NTEXT\",        LONGNVARCHAR);\r\n        addKeyWord( \"LONGNVARCHAR\", LONGNVARCHAR);\r\n        addKeyWord( \"LONG\",         LONG); // alias for Oracle LONG and LONG RAW\r\n        addKeyWord( \"CLOB\",         CLOB);\r\n        addKeyWord( \"NCLOB\",        NCLOB);\r\n        addKeyWord( \"UNIQUEIDENTIFIER\",UNIQUEIDENTIFIER);\r\n        addKeyWord( \"SQL_VARIANT\",  JAVA_OBJECT); // alias for MS SQL Server data type SQL_VARIANT"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "488",
               "end_line": "536",
               "source_code": "        addKeyWord( \"VALUES\",   VALUES);\r\n        addKeyWord( \"AS\",       AS);\r\n        addKeyWord( \"DEFAULT\",  DEFAULT);\r\n        addKeyWord( \"AUTO_INCREMENT\", IDENTITY); // alias for IDENTITY; alias must set first so that key is in the hashtable and not the alias\r\n        addKeyWord( \"IDENTITY\", IDENTITY);\r\n        addKeyWord( \"INNER\",    INNER);\r\n        addKeyWord( \"JOIN\",     JOIN);\r\n        addKeyWord( \"ON\",       ON);\r\n        addKeyWord( \"OUTER\",    OUTER);\r\n        addKeyWord( \"FULL\",     FULL);\r\n        addKeyWord( \"CROSS\",    CROSS);\r\n\t\taddKeyWord( \"USE\",      USE);\r\n\t\taddKeyWord( \"TOP\",      TOP);\r\n\t\taddKeyWord( \"ADD\",      ADD);\r\n        addKeyWord( \"LIMIT\",    LIMIT);\r\n\r\n        addKeyWord( \"DATABASE\", DATABASE);\r\n        addKeyWord( \"TABLE\",    TABLE);\r\n        addKeyWord( \"VIEW\",     VIEW);\r\n        addKeyWord( \"INDEX\",    INDEX);\r\n        addKeyWord( \"PROCEDURE\",PROCEDURE);\r\n\r\n        addKeyWord( \"TRANSACTION\",  TRANSACTION);\r\n        addKeyWord( \"ISOLATION\",    ISOLATION);\r\n        addKeyWord( \"LEVEL\",        LEVEL);\r\n        addKeyWord( \"READ\",         READ);\r\n        addKeyWord( \"COMMITTED\",    COMMITTED);\r\n        addKeyWord( \"UNCOMMITTED\",  UNCOMMITTED);\r\n        addKeyWord( \"REPEATABLE\",   REPEATABLE);\r\n        addKeyWord( \"SERIALIZABLE\", SERIALIZABLE);\r\n        \r\n\t\taddKeyWord( \"CONSTRAINT\", \tCONSTRAINT);\r\n\t\taddKeyWord( \"PRIMARY\",    \tPRIMARY);\r\n\t\taddKeyWord( \"FOREIGN\",     \tFOREIGN);\r\n\t\taddKeyWord( \"KEY\",    \t\tKEY);\r\n\t\taddKeyWord( \"UNIQUE\",\t\tUNIQUE);\r\n\t\taddKeyWord( \"CLUSTERED\",  \tCLUSTERED);\r\n\t\taddKeyWord( \"NONCLUSTERED\", NONCLUSTERED);\r\n\t\taddKeyWord( \"REFERENCES\",   REFERENCES);\r\n\r\n\t\taddKeyWord( \"UNION\", \t\tUNION);\r\n\t\taddKeyWord( \"ALL\",   \t\tALL);\r\n\t\taddKeyWord( \"DISTINCT\",   \tDISTINCT);\r\n\t\taddKeyWord( \"CASE\",   \t\tCASE);\r\n\t\taddKeyWord( \"WHEN\",   \t\tWHEN);\r\n\t\taddKeyWord( \"THEN\",   \t\tTHEN);\r\n\t\taddKeyWord( \"ELSE\",   \t\tELSE);\r\n\t\taddKeyWord( \"END\",   \t\tEND);\r\n\t\taddKeyWord( \"SWITCH\", \t\tSWITCH);"
           }

       },

       {
           "id": "clone_109",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "767",
               "end_line": "775",
               "source_code": "\t\t\t\tcase SQLTokenizer.SQL_LONGVARBINARY:\tdataType = SQLTokenizer.LONGVARBINARY;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_LONGVARCHAR:\t\tdataType = SQLTokenizer.LONGVARCHAR;break;\r\n\t\t\t\tcase SQLTokenizer.SQL_REAL:\t\t\t\tdataType = SQLTokenizer.REAL;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_SMALLINT:\t\t\tdataType = SQLTokenizer.SMALLINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIME:\t\t\t\tdataType = SQLTokenizer.TIME;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TIMESTAMP:\t\tdataType = SQLTokenizer.TIMESTAMP;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_TINYINT:\t\t\tdataType = SQLTokenizer.TINYINT;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARBINARY:\t\tdataType = SQLTokenizer.VARBINARY;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_VARCHAR:\t\t\tdataType = SQLTokenizer.VARCHAR;\tbreak;"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "758",
               "end_line": "766",
               "source_code": "\t\t\t\tcase SQLTokenizer.SQL_BIGINT: \t\t\tdataType = SQLTokenizer.BIGINT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BINARY:\t\t\tdataType = SQLTokenizer.BINARY; \tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_BIT:\t\t\t\tdataType = SQLTokenizer.BIT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_CHAR:\t\t\t\tdataType = SQLTokenizer.CHAR;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DATE:\t\t\t\tdataType = SQLTokenizer.DATE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DECIMAL:\t\t\tdataType = SQLTokenizer.DECIMAL;\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_DOUBLE:\t\t\tdataType = SQLTokenizer.DOUBLE;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_FLOAT:\t\t\tdataType = SQLTokenizer.FLOAT;\t\tbreak;\r\n\t\t\t\tcase SQLTokenizer.SQL_INTEGER:\t\t\tdataType = SQLTokenizer.INT;\t\tbreak;"
           }

       },

       {
           "id": "clone_110",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "512",
               "end_line": "516",
               "source_code": "\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "498",
               "end_line": "502",
               "source_code": "\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           }

       },

       {
           "id": "clone_111",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "341",
               "end_line": "348",
               "source_code": "\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\treturn Types.LONGVARCHAR;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n\t\t\t\t\t\treturn Types.CLOB;\r\n\t\t\tcase SQLTokenizer.JAVA_OBJECT:\r\n\t\t\t\t\t\treturn Types.JAVA_OBJECT;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:"
           },

           "clone": {
               "file": "ExpressionFunctionTimestampDiff.java",
               "start_line": "52",
               "end_line": "59",
               "source_code": "\t\t\tcase SQLTokenizer.HOUR:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_HOUR;\r\n\t\t\tcase SQLTokenizer.D:\r\n\t\t\tcase SQLTokenizer.DAY:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_DAY;\r\n\t\t\tcase SQLTokenizer.WEEK:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_WEEK;\r\n\t\t\tcase SQLTokenizer.MONTH:"
           }

       },

       {
           "id": "clone_112",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1513",
               "end_line": "1517",
               "source_code": "                    break;\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1488",
               "end_line": "1492",
               "source_code": "                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:"
           }

       },

       {
           "id": "clone_113",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "87",
               "end_line": "97",
               "source_code": "\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "279",
               "end_line": "289",
               "source_code": "    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:\r\n    \t\t\treturn true;"
           }

       },

       {
           "id": "clone_114",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1357",
               "end_line": "1361",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return String.valueOf( readLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return String.valueOf( readFloat() );\r\n            case SQLTokenizer.FLOAT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1351",
               "end_line": "1355",
               "source_code": "            case SQLTokenizer.TINYINT:\r\n                    return String.valueOf( readUnsignedByte() );\r\n            case SQLTokenizer.SMALLINT:\r\n                    return String.valueOf( readShort() );\r\n            case SQLTokenizer.INT:"
           }

       },

       {
           "id": "clone_115",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "612",
               "end_line": "618",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "417",
               "end_line": "423",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);"
           }

       },

       {
           "id": "clone_116",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1174",
               "end_line": "1179",
               "source_code": "            case SQLTokenizer.MONEY:\r\n                    return readLong();\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt();\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1105",
               "end_line": "1110",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_117",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1665",
               "end_line": "1680",
               "source_code": "\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIMESTAMP), SQLTokenizer.TIMESTAMP);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.YEAR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionYear();\r\n                break;\r\n            \t\r\n        // system functions:\r\n            case SQLTokenizer.IIF:\r\n        \t\tinvalidParamCount = (paramCount != 3);\r\n            \texpr = new ExpressionFunctionIIF();\r\n        \t\tbreak;\r\n        \tcase SQLTokenizer.SWITCH:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1637",
               "end_line": "1650",
               "source_code": "\t\t\t\tbreak;\r\n            case SQLTokenizer.CURTIME:\r\n            \tinvalidParamCount = (paramCount != 0);\r\n\t\t\t\texpr = new ExpressionValue( new DateTime(DateTime.now(), SQLTokenizer.TIME), SQLTokenizer.TIME);\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:"
           }

       },

       {
           "id": "clone_118",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "573",
               "end_line": "593",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "543",
               "end_line": "563",
               "source_code": "\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 20:\r\n\t\t\tcase 120: // ODBC kannonish; yyyy-mm-dd hh:mi:ss(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);"
           }

       },

       {
           "id": "clone_119",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "274",
               "end_line": "282",
               "source_code": "\t\t\tcase SQLTokenizer.REAL:\r\n                return getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                return getDoubleImpl();"
           },

           "clone": {
               "file": "ExpressionFunctionReturnP1.java",
               "start_line": "73",
               "end_line": "81",
               "source_code": "\t        case SQLTokenizer.DECIMAL:\r\n\t                return getNumeric();\r\n\t        case SQLTokenizer.CHAR:\r\n\t        case SQLTokenizer.NCHAR:\r\n\t        case SQLTokenizer.VARCHAR:\r\n\t        case SQLTokenizer.NVARCHAR:\r\n\t        case SQLTokenizer.LONGNVARCHAR:\r\n\t        case SQLTokenizer.LONGVARCHAR:\r\n\t        \t\treturn getString();"
           }

       },

       {
           "id": "clone_120",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1224",
               "end_line": "1230",
               "source_code": "            case SQLTokenizer.SMALLINT:\r\n                    return new MutableNumeric(readShort());\r\n            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "486",
               "end_line": "492",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_121",

           "clone_type": "type-2",

           "origin": {
               "file": "IndexDescription.java",
               "start_line": "213",
               "end_line": "219",
               "source_code": "\tprivate final void writeMagic(FileChannel raFile) throws Exception{\r\n\t    ByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t    buffer.putInt(MAGIC_INDEX);\r\n\t    buffer.putInt(INDEX_VERSION);\r\n\t    buffer.position(0);\r\n\t    raFile.write(buffer);\r\n\t}"
           },

           "clone": {
               "file": "View.java",
               "start_line": "137",
               "end_line": "144",
               "source_code": "\t@Override\r\n    void writeMagic(FileChannel raFile) throws Exception{\r\n        ByteBuffer buffer = ByteBuffer.allocate(8);\r\n        buffer.putInt(MAGIC_VIEW);\r\n        buffer.putInt(TABLE_VIEW_VERSION);\r\n        buffer.position(0);\r\n        raFile.write(buffer);\r\n\t}"
           }

       },

       {
           "id": "clone_122",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1435",
               "end_line": "1442",
               "source_code": "            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:\r\n                    bytes = new byte[8];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1427",
               "end_line": "1434",
               "source_code": "            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_123",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "793",
               "end_line": "798",
               "source_code": "                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "787",
               "end_line": "792",
               "source_code": "                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.DATE:"
           }

       },

       {
           "id": "clone_124",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "596",
               "end_line": "602",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "438",
               "end_line": "444",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);"
           }

       },

       {
           "id": "clone_125",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1159",
               "end_line": "1171",
               "source_code": "                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "276",
               "end_line": "288",
               "source_code": "    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:"
           }

       },

       {
           "id": "clone_126",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1566",
               "end_line": "1623",
               "source_code": "                break;\r\n            case SQLTokenizer.DIFFERENCE:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionDifference();\r\n                break;\r\n            case SQLTokenizer.INSERT:\r\n                invalidParamCount = (paramCount != 4);\r\n                expr = new ExpressionFunctionInsert();\r\n                break;\r\n            case SQLTokenizer.LCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLCase();\r\n                break;\r\n            case SQLTokenizer.LEFT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionLeft();\r\n                break;\r\n\t\t\tcase SQLTokenizer.LENGTH:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionLength();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.LOCATE:\r\n            \tinvalidParamCount = (paramCount != 2) && (paramCount != 3);\r\n            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1490",
               "end_line": "1549",
               "source_code": "                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:\r\n                invalidParamCount =  (paramCount != 0) && (paramCount != 1);\r\n                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:"
           }

       },

       {
           "id": "clone_127",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1068",
               "end_line": "1078",
               "source_code": "            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2float( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1031",
               "end_line": "1041",
               "source_code": "            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2float( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();"
           }

       },

       {
           "id": "clone_128",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1165",
               "end_line": "1169",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() * 10000L;\r\n            case SQLTokenizer.REAL:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "357",
               "end_line": "361",
               "source_code": "            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_129",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunction.java",
               "start_line": "80",
               "end_line": "85",
               "source_code": "\t\t\tcase 2:\r\n\t\t\t\tparam3 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tparam4 = param;\r\n\t\t\t\tbreak;"
           },

           "clone": {
               "file": "ExpressionFunction.java",
               "start_line": "74",
               "end_line": "79",
               "source_code": "\t\t\tcase 0:\r\n\t\t\t\tparam1 = param;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tparam2 = param;\r\n\t\t\t\tbreak;"
           }

       },

       {
           "id": "clone_130",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1112",
               "end_line": "1117",
               "source_code": "            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000.0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000.0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "982",
               "end_line": "987",
               "source_code": "            case SQLTokenizer.MONEY:\r\n                    return readLong() / 10000;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() / 10000;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           }

       },

       {
           "id": "clone_131",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "792",
               "end_line": "797",
               "source_code": "            case SQLTokenizer.DATE:\r\n                    writeDate( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    writeSmallDateTime( expr.getLong() );\r\n                    break;"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "786",
               "end_line": "791",
               "source_code": "            case SQLTokenizer.TIMESTAMP:\r\n                    writeTimestamp( expr.getLong() );\r\n                    break;\r\n            case SQLTokenizer.TIME:\r\n                    writeTime( expr.getLong() );\r\n                    break;"
           }

       },

       {
           "id": "clone_132",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "410",
               "end_line": "434",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 6: // dd mon yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "382",
               "end_line": "406",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');"
           }

       },

       {
           "id": "clone_133",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "323",
               "end_line": "334",
               "source_code": "\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\treturn Types.FLOAT;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\treturn Types.DOUBLE;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\treturn Types.DATE;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\treturn Types.TIME;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\treturn Types.TIMESTAMP;\r\n\t\t\tcase SQLTokenizer.CHAR:"
           },

           "clone": {
               "file": "ExpressionFunctionTimestampDiff.java",
               "start_line": "46",
               "end_line": "57",
               "source_code": "\t\t\tcase SQLTokenizer.MILLISECOND:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_FRAC_SECOND;\r\n\t\t\tcase SQLTokenizer.SECOND:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_SECOND;\r\n\t\t\tcase SQLTokenizer.MINUTE:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_MINUTE;\r\n\t\t\tcase SQLTokenizer.HOUR:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_HOUR;\r\n\t\t\tcase SQLTokenizer.D:\r\n\t\t\tcase SQLTokenizer.DAY:\r\n\t\t\t\treturn SQLTokenizer.SQL_TSI_DAY;\r\n\t\t\tcase SQLTokenizer.WEEK:"
           }

       },

       {
           "id": "clone_134",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "578",
               "end_line": "622",
               "source_code": "        addKeyWord( \"BIT\",          BIT);\r\n        addKeyWord( \"BOOLEAN\",      BOOLEAN);\r\n        addKeyWord( \"BINARY\",       BINARY);\r\n        addKeyWord( \"VARBINARY\",    VARBINARY);\r\n\t\taddKeyWord( \"RAW\",          RAW); // alias for Oracle RAW and LONG RAW\r\n\t\taddKeyWord( \"IMAGE\",        LONGVARBINARY); // alias for MS SQL Server data type IMAGE\r\n        addKeyWord( \"LONGVARBINARY\",LONGVARBINARY);\r\n        addKeyWord( \"BLOB\",         BLOB);\r\n        addKeyWord( \"BYTE\",         TINYINT);\r\n        addKeyWord( \"TINYINT\",      TINYINT);\r\n        addKeyWord( \"SMALLINT\",     SMALLINT);\r\n\t\taddKeyWord( \"INTEGER\",      INT);\r\n        addKeyWord( \"INT\",          INT);\r\n        addKeyWord( \"SERIAL\",       COUNTER); //alias for MySQL and PostgreSQL\r\n        addKeyWord( \"COUNTER\",      COUNTER);\r\n        addKeyWord( \"BIGINT\",       BIGINT);\r\n        addKeyWord( \"SMALLMONEY\",   SMALLMONEY);\r\n        addKeyWord( \"MONEY\",        MONEY);\r\n\t\taddKeyWord( \"NUMBER\",       DECIMAL);\r\n\t\taddKeyWord( \"VARNUM\",       DECIMAL);\r\n\t\taddKeyWord( \"DECIMAL\",      DECIMAL);\r\n        addKeyWord( \"NUMERIC\",      NUMERIC);\r\n        addKeyWord( \"REAL\",         REAL);\r\n        addKeyWord( \"FLOAT\",        FLOAT);\r\n        addKeyWord( \"DOUBLE\",       DOUBLE);\r\n        addKeyWord( \"DATE\",         DATE);\r\n        addKeyWord( \"TIME\",         TIME);\r\n        addKeyWord( \"DATETIME\",     TIMESTAMP); // alias for MS SQL Server data type DATETIME\r\n        addKeyWord( \"TIMESTAMP\",    TIMESTAMP);\r\n        addKeyWord( \"SMALLDATETIME\",SMALLDATETIME);\r\n        addKeyWord( \"CHARACTER\",    CHAR); // alias for CHAR\r\n        addKeyWord( \"CHAR\",         CHAR);\r\n        addKeyWord( \"NCHAR\",        NCHAR);\r\n        addKeyWord( \"VARCHAR2\",     VARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"VARCHAR\",      VARCHAR);\r\n        addKeyWord( \"NVARCHAR2\",    NVARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"NVARCHAR\",     NVARCHAR);\r\n\t\taddKeyWord( \"SYSNAME\",      SYSNAME);\r\n        addKeyWord( \"TEXT\",         LONGVARCHAR);\r\n        addKeyWord( \"LONGVARCHAR\",  LONGVARCHAR);\r\n        addKeyWord( \"NTEXT\",        LONGNVARCHAR);\r\n        addKeyWord( \"LONGNVARCHAR\", LONGNVARCHAR);\r\n        addKeyWord( \"LONG\",         LONG); // alias for Oracle LONG and LONG RAW\r\n        addKeyWord( \"CLOB\",         CLOB);\r\n        addKeyWord( \"NCLOB\",        NCLOB);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "488",
               "end_line": "536",
               "source_code": "        addKeyWord( \"VALUES\",   VALUES);\r\n        addKeyWord( \"AS\",       AS);\r\n        addKeyWord( \"DEFAULT\",  DEFAULT);\r\n        addKeyWord( \"AUTO_INCREMENT\", IDENTITY); // alias for IDENTITY; alias must set first so that key is in the hashtable and not the alias\r\n        addKeyWord( \"IDENTITY\", IDENTITY);\r\n        addKeyWord( \"INNER\",    INNER);\r\n        addKeyWord( \"JOIN\",     JOIN);\r\n        addKeyWord( \"ON\",       ON);\r\n        addKeyWord( \"OUTER\",    OUTER);\r\n        addKeyWord( \"FULL\",     FULL);\r\n        addKeyWord( \"CROSS\",    CROSS);\r\n\t\taddKeyWord( \"USE\",      USE);\r\n\t\taddKeyWord( \"TOP\",      TOP);\r\n\t\taddKeyWord( \"ADD\",      ADD);\r\n        addKeyWord( \"LIMIT\",    LIMIT);\r\n\r\n        addKeyWord( \"DATABASE\", DATABASE);\r\n        addKeyWord( \"TABLE\",    TABLE);\r\n        addKeyWord( \"VIEW\",     VIEW);\r\n        addKeyWord( \"INDEX\",    INDEX);\r\n        addKeyWord( \"PROCEDURE\",PROCEDURE);\r\n\r\n        addKeyWord( \"TRANSACTION\",  TRANSACTION);\r\n        addKeyWord( \"ISOLATION\",    ISOLATION);\r\n        addKeyWord( \"LEVEL\",        LEVEL);\r\n        addKeyWord( \"READ\",         READ);\r\n        addKeyWord( \"COMMITTED\",    COMMITTED);\r\n        addKeyWord( \"UNCOMMITTED\",  UNCOMMITTED);\r\n        addKeyWord( \"REPEATABLE\",   REPEATABLE);\r\n        addKeyWord( \"SERIALIZABLE\", SERIALIZABLE);\r\n        \r\n\t\taddKeyWord( \"CONSTRAINT\", \tCONSTRAINT);\r\n\t\taddKeyWord( \"PRIMARY\",    \tPRIMARY);\r\n\t\taddKeyWord( \"FOREIGN\",     \tFOREIGN);\r\n\t\taddKeyWord( \"KEY\",    \t\tKEY);\r\n\t\taddKeyWord( \"UNIQUE\",\t\tUNIQUE);\r\n\t\taddKeyWord( \"CLUSTERED\",  \tCLUSTERED);\r\n\t\taddKeyWord( \"NONCLUSTERED\", NONCLUSTERED);\r\n\t\taddKeyWord( \"REFERENCES\",   REFERENCES);\r\n\r\n\t\taddKeyWord( \"UNION\", \t\tUNION);\r\n\t\taddKeyWord( \"ALL\",   \t\tALL);\r\n\t\taddKeyWord( \"DISTINCT\",   \tDISTINCT);\r\n\t\taddKeyWord( \"CASE\",   \t\tCASE);\r\n\t\taddKeyWord( \"WHEN\",   \t\tWHEN);\r\n\t\taddKeyWord( \"THEN\",   \t\tTHEN);\r\n\t\taddKeyWord( \"ELSE\",   \t\tELSE);\r\n\t\taddKeyWord( \"END\",   \t\tEND);\r\n\t\taddKeyWord( \"SWITCH\", \t\tSWITCH);"
           }

       },

       {
           "id": "clone_135",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "995",
               "end_line": "999",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Long.parseLong( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "990",
               "end_line": "994",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Long.parseLong( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_136",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1871",
               "end_line": "1879",
               "source_code": "\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.RIGHT_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n\t\t\t\tcase SQLTokenizer.FULL:\r\n\t\t\t\t\ttoken = nextToken(MISSING_OUTER_JOIN);\r\n\t\t\t\t\tif(token.value == SQLTokenizer.OUTER)\r\n\t\t\t\t\t\ttoken = nextToken(MISSING_JOIN);\r\n\t\t\t\t\tfromSource = join( cmd, tables, fromSource, Join.FULL_JOIN );\r\n\t\t\t\t\tbreak;                \t\r\n                case SQLTokenizer.PARENTHESIS_R:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1859",
               "end_line": "1867",
               "source_code": "                    fromSource = join( cmd, tables, fromSource, Join.INNER_JOIN );\r\n                    break;\r\n                case SQLTokenizer.LEFT:\r\n                    token = nextToken(MISSING_OUTER_JOIN);\r\n                \tif(token.value == SQLTokenizer.OUTER)\r\n                \t\ttoken = nextToken(MISSING_JOIN);\r\n                    fromSource = join( cmd, tables, fromSource, Join.LEFT_JOIN );\r\n                    break;\r\n                case SQLTokenizer.RIGHT:"
           }

       },

       {
           "id": "clone_137",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "317",
               "end_line": "332",
               "source_code": "\t\t\tcase SQLTokenizer.DECIMAL:\r\n\t\t\t\t\t\treturn Types.DECIMAL;\r\n\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\t\t\t\treturn Types.NUMERIC;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\t\t\treturn Types.REAL;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\t\t\t\treturn Types.FLOAT;\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\t\t\treturn Types.DOUBLE;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\t\treturn Types.DATE;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\treturn Types.TIME;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "301",
               "end_line": "316",
               "source_code": "\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\t\t\t\treturn Types.VARBINARY;\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\t\t\t\treturn Types.LONGVARBINARY;\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\t\t\treturn Types.BLOB;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\t\t\treturn Types.TINYINT;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\t\t\treturn Types.SMALLINT;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\t\t\treturn Types.INTEGER;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\t\t\treturn Types.BIGINT;\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\tcase SQLTokenizer.MONEY:"
           }

       },

       {
           "id": "clone_138",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "453",
               "end_line": "459",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 107: // Mon dd, yyyy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "445",
               "end_line": "451",
               "source_code": "\t\t\t\treturn buf.toString();\r\n\t\t\tcase 7: // Mon dd, yy\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(',');\r\n\t\t\t\tbuf.append(' ');"
           }

       },

       {
           "id": "clone_139",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "941",
               "end_line": "945",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn (int)readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn (int)readTime();\r\n\t\t\tcase SQLTokenizer.DATE:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "909",
               "end_line": "913",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_140",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "286",
               "end_line": "290",
               "source_code": "            case Types.TIMESTAMP:\r\n                    return \"java.sql.Timestamp\";\r\n            case Types.CHAR:\r\n            case Types.VARCHAR:\r\n            case Types.LONGVARCHAR:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "264",
               "end_line": "268",
               "source_code": "            case Types.BOOLEAN:\r\n                    return \"java.lang.Boolean\";\r\n            case Types.BINARY:\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:"
           }

       },

       {
           "id": "clone_141",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1494",
               "end_line": "1504",
               "source_code": "                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "677",
               "end_line": "687",
               "source_code": "                case SQLTokenizer.SMALLINT:\r\n                case SQLTokenizer.BINARY:\r\n                case SQLTokenizer.VARBINARY:\r\n                case SQLTokenizer.CHAR:\r\n                case SQLTokenizer.NCHAR:\r\n                case SQLTokenizer.VARCHAR:\r\n                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_142",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "274",
               "end_line": "279",
               "source_code": "            case Types.DECIMAL:\r\n            case Types.NUMERIC:\r\n                    return \"java.math.BigDecimal\";\r\n            case Types.REAL:\r\n                    return \"java.lang.Float\";\r\n            case Types.FLOAT:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "267",
               "end_line": "272",
               "source_code": "            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n                    return \"[B\";\r\n            case Types.BLOB:\r\n                    return \"java.sql.Blob\";\r\n            case Types.BIGINT:"
           }

       },

       {
           "id": "clone_143",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1589",
               "end_line": "1633",
               "source_code": "            \texpr = new ExpressionFunctionLocate();\r\n            \tbreak;\r\n            case SQLTokenizer.LTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLTrim();\r\n                break;\r\n            case SQLTokenizer.OCTETLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1469",
               "end_line": "1511",
               "source_code": "                expr = new ExpressionFunctionCos();\r\n                break;\r\n            case SQLTokenizer.COT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionCot();\r\n                break;\r\n            case SQLTokenizer.DEGREES:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionDegrees();\r\n                break;\r\n            case SQLTokenizer.EXP:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionExp();\r\n                break;\r\n            case SQLTokenizer.FLOOR:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionFloor();\r\n                break;\r\n            case SQLTokenizer.LOG:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog();\r\n                break;\r\n            case SQLTokenizer.LOG10:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionLog10();\r\n                break;\r\n            case SQLTokenizer.MOD:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionMod();\r\n                break;\r\n            case SQLTokenizer.PI:\r\n                invalidParamCount = (paramCount != 0);\r\n                expr = new ExpressionFunctionPI();\r\n                break;\r\n            case SQLTokenizer.POWER:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionPower();\r\n                break;\r\n            case SQLTokenizer.RADIANS:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRadians();\r\n                break;\r\n            case SQLTokenizer.RAND:"
           }

       },

       {
           "id": "clone_144",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionConvert.java",
               "start_line": "210",
               "end_line": "214",
               "source_code": "\t\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\ttype = SQLTokenizer.TIMESTAMP;\r\n\t\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\tcase SQLTokenizer.TIME:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "796",
               "end_line": "801",
               "source_code": "\t\t\tcase SQLTokenizer.RAW:\r\n\t\t\t\tdataType = SQLTokenizer.VARBINARY;\r\n\t\t\t\t// no break;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:"
           }

       },

       {
           "id": "clone_145",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1124",
               "end_line": "1128",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Double.parseDouble( readLongString() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1119",
               "end_line": "1123",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Double.parseDouble( readString() );"
           }

       },

       {
           "id": "clone_146",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1452",
               "end_line": "1456",
               "source_code": "            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1447",
               "end_line": "1451",
               "source_code": "            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:"
           }

       },

       {
           "id": "clone_147",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1449",
               "end_line": "1453",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1444",
               "end_line": "1448",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();"
           }

       },

       {
           "id": "clone_148",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1187",
               "end_line": "1191",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1182",
               "end_line": "1186",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_149",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "485",
               "end_line": "515",
               "source_code": "\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 110: // USA mm-dd-yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 11: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 111: // Japan yy/mm/dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 12: // ISO yymmdd"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "360",
               "end_line": "390",
               "source_code": "\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 1:   // USA mm/dd/yy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 101:   // USA mm/dd/yyyy\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 2: // ANSI yy.mm.dd\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 102: // ANSI yyyy.mm.dd\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 3: // britsh dd/mm/yy"
           }

       },

       {
           "id": "clone_150",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1451",
               "end_line": "1455",
               "source_code": "            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1446",
               "end_line": "1450",
               "source_code": "            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:"
           }

       },

       {
           "id": "clone_151",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1597",
               "end_line": "1635",
               "source_code": "                expr = new ExpressionFunctionOctetLen();\r\n                break;\r\n            case SQLTokenizer.REPEAT:\r\n                invalidParamCount = (paramCount != 2);\r\n                expr = new ExpressionFunctionRepeat();\r\n                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionUCase();\r\n                break;\r\n                \r\n        // date time functions\r\n            case SQLTokenizer.CURDATE:\r\n            case SQLTokenizer.CURRENTDATE:\r\n            \tinvalidParamCount = (paramCount != 0);"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1513",
               "end_line": "1551",
               "source_code": "                expr = new ExpressionFunctionRand();\r\n                break;\r\n            case SQLTokenizer.ROUND:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionRound();\r\n                break;\r\n            case SQLTokenizer.SIN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSin();\r\n                break;\r\n            case SQLTokenizer.SIGN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSign();\r\n                break;\r\n            case SQLTokenizer.SQRT:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSqrt();\r\n                break;\r\n            case SQLTokenizer.TAN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionTan();\r\n                break;\r\n            case SQLTokenizer.TRUNCATE:\r\n                invalidParamCount =  (paramCount != 2);\r\n                expr = new ExpressionFunctionTruncate();\r\n                break;\r\n         \r\n        // string functions:\r\n\t\t\tcase SQLTokenizer.ASCII:\r\n\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionAscii();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.BITLEN:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionBitLen();\r\n                break;\r\n            case SQLTokenizer.CHARLEN:\r\n            case SQLTokenizer.CHARACTLEN:\r\n                invalidParamCount = (paramCount != 1);"
           }

       },

       {
           "id": "clone_152",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1641",
               "end_line": "1667",
               "source_code": "\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFMONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFWEEK:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfWeek();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.DAYOFYEAR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionDayOfYear();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.HOUR:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionHour();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MINUTE:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMinute();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.MONTH:\r\n            \tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\texpr = new ExpressionFunctionMonth();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.NOW:\r\n            \tinvalidParamCount = (paramCount != 0);"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1602",
               "end_line": "1628",
               "source_code": "                break;\r\n            case SQLTokenizer.REPLACE:\r\n                invalidParamCount = (paramCount != 3);\r\n                expr = new ExpressionFunctionReplace();\r\n                break;\r\n\t\t\tcase SQLTokenizer.RIGHT:\r\n\t\t\t\tinvalidParamCount = (paramCount != 2);\r\n\t\t\t\texpr = new ExpressionFunctionRight();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.RTRIM:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionRTrim();\r\n                break;\r\n            case SQLTokenizer.SPACE:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSpace();\r\n                break;\r\n            case SQLTokenizer.SOUNDEX:\r\n                invalidParamCount = (paramCount != 1);\r\n                expr = new ExpressionFunctionSoundex();\r\n                break;\r\n\t\t\tcase SQLTokenizer.SUBSTRING:\r\n\t\t\t\tinvalidParamCount = (paramCount != 3);\r\n\t\t\t\texpr = new ExpressionFunctionSubstring();\r\n\t\t\t\tbreak;\r\n            case SQLTokenizer.UCASE:\r\n                invalidParamCount = (paramCount != 1);"
           }

       },

       {
           "id": "clone_153",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "266",
               "end_line": "270",
               "source_code": "            case Types.BINARY:\r\n            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n                    return \"[B\";\r\n            case Types.BLOB:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "259",
               "end_line": "263",
               "source_code": "            case Types.TINYINT:\r\n            case Types.SMALLINT:\r\n            case Types.INTEGER:\r\n                    return \"java.lang.Integer\";\r\n            case Types.BIT:"
           }

       },

       {
           "id": "clone_154",

           "clone_type": "type-2",

           "origin": {
               "file": "Utils.java",
               "start_line": "297",
               "end_line": "313",
               "source_code": "        chars[19] = digits[ (daten[offset+8] >> 4) & 0x0F ];\r\n        chars[20] = digits[ (daten[offset+8]     ) & 0x0F ];\r\n        chars[21] = digits[ (daten[offset+9] >> 4) & 0x0F ];\r\n        chars[22] = digits[ (daten[offset+9]     ) & 0x0F ];\r\n\r\n        chars[24] = digits[ (daten[offset+10] >> 4) & 0x0F ];\r\n        chars[25] = digits[ (daten[offset+10]     ) & 0x0F ];\r\n        chars[26] = digits[ (daten[offset+11] >> 4) & 0x0F ];\r\n        chars[27] = digits[ (daten[offset+11]     ) & 0x0F ];\r\n        chars[28] = digits[ (daten[offset+12] >> 4) & 0x0F ];\r\n        chars[29] = digits[ (daten[offset+12]     ) & 0x0F ];\r\n        chars[30] = digits[ (daten[offset+13] >> 4) & 0x0F ];\r\n        chars[31] = digits[ (daten[offset+13]     ) & 0x0F ];\r\n        chars[32] = digits[ (daten[offset+14] >> 4) & 0x0F ];\r\n        chars[33] = digits[ (daten[offset+14]     ) & 0x0F ];\r\n        chars[34] = digits[ (daten[offset+15] >> 4) & 0x0F ];\r\n        chars[35] = digits[ (daten[offset+15]     ) & 0x0F ];"
           },

           "clone": {
               "file": "Utils.java",
               "start_line": "278",
               "end_line": "295",
               "source_code": "        chars[0] = digits[ (daten[offset+3] >> 4) & 0x0F ];\r\n        chars[1] = digits[ (daten[offset+3]     ) & 0x0F ];\r\n        chars[2] = digits[ (daten[offset+2] >> 4) & 0x0F ];\r\n        chars[3] = digits[ (daten[offset+2]     ) & 0x0F ];\r\n        chars[4] = digits[ (daten[offset+1] >> 4) & 0x0F ];\r\n        chars[5] = digits[ (daten[offset+1]     ) & 0x0F ];\r\n        chars[6] = digits[ (daten[offset+0] >> 4) & 0x0F ];\r\n        chars[7] = digits[ (daten[offset+0]     ) & 0x0F ];\r\n\r\n        chars[ 9] = digits[ (daten[offset+5] >> 4) & 0x0F ];\r\n        chars[10] = digits[ (daten[offset+5]     ) & 0x0F ];\r\n        chars[11] = digits[ (daten[offset+4] >> 4) & 0x0F ];\r\n        chars[12] = digits[ (daten[offset+4]     ) & 0x0F ];\r\n\r\n        chars[14] = digits[ (daten[offset+7] >> 4) & 0x0F ];\r\n        chars[15] = digits[ (daten[offset+7]     ) & 0x0F ];\r\n        chars[16] = digits[ (daten[offset+6] >> 4) & 0x0F ];\r\n        chars[17] = digits[ (daten[offset+6]     ) & 0x0F ];"
           }

       },

       {
           "id": "clone_155",

           "clone_type": "type-2",

           "origin": {
               "file": "Utils.java",
               "start_line": "198",
               "end_line": "202",
               "source_code": "\t\tresult[0] = (byte)(value >> 24);\r\n\t\tresult[1] = (byte)(value >> 16);\r\n\t\tresult[2] = (byte)(value >> 8);\r\n\t\tresult[3] = (byte)(value);\r\n\t\treturn result;"
           },

           "clone": {
               "file": "Utils.java",
               "start_line": "183",
               "end_line": "187",
               "source_code": "        result[4] = (byte)(value >> 24);\r\n        result[5] = (byte)(value >> 16);\r\n        result[6] = (byte)(value >> 8);\r\n        result[7] = (byte)(value);\r\n        return result;"
           }

       },

       {
           "id": "clone_156",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "601",
               "end_line": "613",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 131: // Kuwaiti  dd/mm/yy hh:mi:ss:mmmAM"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "475",
               "end_line": "487",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatHour12( details.hour, buf );\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatMillis( details.millis, buf);\r\n\t\t\t\tbuf.append( details.hour < 12 ? \"AM\" : \"PM\" );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 10: // USA mm-dd-yy"
           }

       },

       {
           "id": "clone_157",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "389",
               "end_line": "394",
               "source_code": "    \tint newSize = offset + 8;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 56);\r\n        page[ offset++ ] = (byte)(value >> 48);\r\n        page[ offset++ ] = (byte)(value >> 40);"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "372",
               "end_line": "377",
               "source_code": "    \tint newSize = offset + 4;\r\n        if(newSize > page.length) resizePage(newSize);\r\n\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);"
           }

       },

       {
           "id": "clone_158",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "529",
               "end_line": "534",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf );\r\n\t\t\t\tbuf.append(':');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "472",
               "end_line": "477",
               "source_code": "\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');"
           }

       },

       {
           "id": "clone_159",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1450",
               "end_line": "1454",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString().getBytes();\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1445",
               "end_line": "1449",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString().getBytes();\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_160",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "582",
               "end_line": "597",
               "source_code": "\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "566",
               "end_line": "581",
               "source_code": "\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 26:"
           }

       },

       {
           "id": "clone_161",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionReturnP1Number.java",
               "start_line": "64",
               "end_line": "68",
               "source_code": "\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new MutableNumeric(getLong());\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn new MutableNumeric(getMoney(), 4);\r\n\t\t\tcase SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1233",
               "end_line": "1237",
               "source_code": "            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:\r\n                    return new MutableNumeric( readLong(), 4);\r\n            case SQLTokenizer.SMALLMONEY:"
           }

       },

       {
           "id": "clone_162",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "929",
               "end_line": "935",
               "source_code": "\t\taddKeyWord( \"COUNT\",       \tCOUNT);\r\n\t\taddKeyWord( \"MIN\",      \tMIN);\r\n\t\taddKeyWord( \"MAX\",      \tMAX);\r\n\t\taddKeyWord( \"SUM\",         \tSUM);\r\n\t\taddKeyWord( \"FIRST\",        FIRST);\r\n\t\taddKeyWord( \"LAST\",         LAST);\r\n\t\taddKeyWord( \"AVG\",          AVG);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "910",
               "end_line": "916",
               "source_code": "\t\taddKeyWord( \"SQL_REAL\",\t\t\tSQL_REAL);\r\n\t\taddKeyWord( \"SQL_SMALLINT\",\t\tSQL_SMALLINT);\r\n\t\taddKeyWord( \"SQL_TIME\",\t\t\tSQL_TIME);\r\n\t\taddKeyWord( \"SQL_TIMESTAMP\",\tSQL_TIMESTAMP);\r\n\t\taddKeyWord( \"SQL_TINYINT\",\t\tSQL_TINYINT);\r\n\t\taddKeyWord( \"SQL_VARBINARY\",\tSQL_VARBINARY);\r\n\t\taddKeyWord( \"SQL_VARCHAR\",\t\tSQL_VARCHAR);"
           }

       },

       {
           "id": "clone_163",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "85",
               "end_line": "92",
               "source_code": "            case 'Q':\r\n            case 'S':\r\n            case 'X':\r\n            case 'Z':\r\n                c = '2';\r\n                break;\r\n            case 'D':\r\n            case 'T':"
           },

           "clone": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "75",
               "end_line": "82",
               "source_code": "            case 'B':\r\n            case 'F':\r\n            case 'P':\r\n            case 'V':\r\n                c = '1';\r\n                break;\r\n            case 'C':\r\n            case 'G':"
           }

       },

       {
           "id": "clone_164",

           "clone_type": "type-2",

           "origin": {
               "file": "IndexDescription.java",
               "start_line": "159",
               "end_line": "164",
               "source_code": "\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.INDEX_EXISTS, name);\r\n\t\tFileChannel randomFile = Utils.openRaFile( file, database.isReadOnly() );\r\n        con.add(new CreateFile(file, randomFile, con, database));\r\n\t\twriteMagic(randomFile);\r\n\t\treturn randomFile;"
           },

           "clone": {
               "file": "TableView.java",
               "start_line": "141",
               "end_line": "146",
               "source_code": "\t\tboolean ok = file.createNewFile();\r\n\t\tif(!ok) throw SmallSQLException.create(Language.TABLE_EXISTENT, name);\r\n\t\tFileChannel raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\tcon.add(new CreateFile(file, raFile, con, database));\r\n\t\twriteMagic(raFile);\r\n\t\treturn raFile;"
           }

       },

       {
           "id": "clone_165",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1478",
               "end_line": "1503",
               "source_code": "                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.BINARY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "683",
               "end_line": "708",
               "source_code": "                case SQLTokenizer.NVARCHAR:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:\r\n                case SQLTokenizer.SMALLMONEY:\r\n                case SQLTokenizer.TIME:\r\n                case SQLTokenizer.DATE:\r\n                case SQLTokenizer.SMALLDATETIME:\r\n                    offset += 4;\r\n                    break;\r\n                case SQLTokenizer.BIGINT:\r\n                case SQLTokenizer.FLOAT:\r\n                case SQLTokenizer.DOUBLE:\r\n                case SQLTokenizer.MONEY:\r\n                case SQLTokenizer.JAVA_OBJECT:\r\n                case SQLTokenizer.LONGVARBINARY:\r\n                case SQLTokenizer.BLOB:\r\n\t\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\t\tcase SQLTokenizer.NCLOB:\r\n                case SQLTokenizer.LONGNVARCHAR:\r\n                case SQLTokenizer.LONGVARCHAR:\r\n                case SQLTokenizer.TIMESTAMP:\r\n                    offset += 8;\r\n                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:"
           }

       },

       {
           "id": "clone_166",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "907",
               "end_line": "914",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return (int)readLong();\r\n            case SQLTokenizer.REAL:\r\n                    return (int)readFloat();\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "184",
               "end_line": "191",
               "source_code": "            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl();\r\n            case SQLTokenizer.BIGINT:\r\n                return (int)getLongImpl();\r\n\t\t\tcase SQLTokenizer.REAL:\r\n                return (int)getFloatImpl();\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_167",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1429",
               "end_line": "1437",
               "source_code": "            case SQLTokenizer.SMALLDATETIME:\r\n                    bytes = new byte[4];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.TIMESTAMP:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1420",
               "end_line": "1428",
               "source_code": "            case SQLTokenizer.SMALLINT:\r\n                    bytes = new byte[2];\r\n                    System.arraycopy( page, valueOffset, bytes, 0, bytes.length);\r\n                    return bytes;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.SMALLMONEY:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:"
           }

       },

       {
           "id": "clone_168",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1136",
               "end_line": "1145",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1071",
               "end_line": "1080",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();\r\n\t\t\tdefault:\r\n\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"REAL\" });"
           }

       },

       {
           "id": "clone_169",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "861",
               "end_line": "865",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "856",
               "end_line": "860",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );"
           }

       },

       {
           "id": "clone_170",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1244",
               "end_line": "1248",
               "source_code": "            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "492",
               "end_line": "496",
               "source_code": "            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:\r\n            case SQLTokenizer.SMALLMONEY:"
           }

       },

       {
           "id": "clone_171",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "545",
               "end_line": "550",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj == Boolean.TRUE) ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "462",
               "end_line": "467",
               "source_code": "            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:"
           }

       },

       {
           "id": "clone_172",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "883",
               "end_line": "887",
               "source_code": "        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmd = new CommandTable( con.log, catalog, tableName, SQLTokenizer.INDEX );"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "581",
               "end_line": "585",
               "source_code": "        String catalog;\r\n        String tableName = catalog = nextIdentifier();\r\n        tableName = nextIdentiferPart(tableName);\r\n        if(tableName == catalog) catalog = null;\r\n        CommandTable cmdCreate = new CommandTable( con.log, catalog, tableName, SQLTokenizer.CREATE );"
           }

       },

       {
           "id": "clone_173",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "282",
               "end_line": "289",
               "source_code": "            case Types.DATE:\r\n                    return \"java.sql.Date\";\r\n            case Types.TIME:\r\n                    return \"java.sql.Time\";\r\n            case Types.TIMESTAMP:\r\n                    return \"java.sql.Timestamp\";\r\n            case Types.CHAR:\r\n            case Types.VARCHAR:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "268",
               "end_line": "275",
               "source_code": "            case Types.LONGVARBINARY:\r\n                    return \"[B\";\r\n            case Types.BLOB:\r\n                    return \"java.sql.Blob\";\r\n            case Types.BIGINT:\r\n                    return \"java.lang.Long\";\r\n            case Types.DECIMAL:\r\n            case Types.NUMERIC:"
           }

       },

       {
           "id": "clone_174",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1278",
               "end_line": "1284",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "478",
               "end_line": "484",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return getBoolean() ? Boolean.TRUE : Boolean.FALSE;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return getBytes();\r\n            case SQLTokenizer.TINYINT:"
           }

       },

       {
           "id": "clone_175",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1299",
               "end_line": "1307",
               "source_code": "            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue(readInt());\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return readNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "496",
               "end_line": "504",
               "source_code": "            case SQLTokenizer.SMALLMONEY:\r\n                    return Money.createFromUnscaledValue( getMoney() );\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:\r\n                    return getNumeric();\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:"
           }

       },

       {
           "id": "clone_176",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "97",
               "end_line": "103",
               "source_code": "                break;\r\n            case 'M':\r\n            case 'N':\r\n                c = '5';\r\n                break;\r\n            case 'R':\r\n                c = '6';"
           },

           "clone": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "90",
               "end_line": "96",
               "source_code": "                break;\r\n            case 'D':\r\n            case 'T':\r\n                c = '3';\r\n                break;\r\n            case 'L':\r\n                c = '4';"
           }

       },

       {
           "id": "clone_177",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1731",
               "end_line": "1741",
               "source_code": "\t\t\t\t\texpr = new ExpressionName( Expression.MIN );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.FIRST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.FIRST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.LAST:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.LAST );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.AVG:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1719",
               "end_line": "1729",
               "source_code": "\t\t\t\t\texpr = new ExpressionName( Expression.COUNT );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.SUM:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.SUM );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MAX:\r\n\t\t\t\t\tinvalidParamCount = (paramCount != 1);\r\n\t\t\t\t\texpr = new ExpressionName( Expression.MAX );\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase SQLTokenizer.MIN:"
           }

       },

       {
           "id": "clone_178",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1160",
               "end_line": "1172",
               "source_code": "                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:\r\n                case SQLTokenizer.BIT_AND:\r\n                case SQLTokenizer.BIT_OR:\r\n                case SQLTokenizer.BIT_XOR:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "276",
               "end_line": "288",
               "source_code": "    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:"
           }

       },

       {
           "id": "clone_179",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "436",
               "end_line": "441",
               "source_code": "\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 106: // dd mon yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "422",
               "end_line": "427",
               "source_code": "\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 105: // italiano dd-mm-yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');"
           }

       },

       {
           "id": "clone_180",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1059",
               "end_line": "1063",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1054",
               "end_line": "1058",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );"
           }

       },

       {
           "id": "clone_181",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "166",
               "end_line": "175",
               "source_code": "\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 1;\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "126",
               "end_line": "135",
               "source_code": "\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 6;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_182",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSet.java",
               "start_line": "798",
               "end_line": "810",
               "source_code": "    public Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTimestamp(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Timestamp(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"
           },

           "clone": {
               "file": "SSResultSet.java",
               "start_line": "778",
               "end_line": "790",
               "source_code": "    public Time getTime(int columnIndex, Calendar cal) throws SQLException {\r\n        try{\r\n            if(cal == null){\r\n                return getTime(columnIndex);\r\n            }\r\n            Expression expr = getValue(columnIndex);\r\n            wasNull = expr.isNull();\r\n            if(wasNull) return null;\r\n            return new Time(DateTime.addDateTimeOffset( expr.getLong(), cal.getTimeZone() ));\r\n        }catch(Exception e){\r\n            throw SmallSQLException.createFromException( e );\r\n        }\r\n    }"
           }

       },

       {
           "id": "clone_183",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "197",
               "end_line": "208",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\treturn 23;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\treturn 8;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn 16;\r\n\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "122",
               "end_line": "133",
               "source_code": "\t\t\tcase SQLTokenizer.BIT:\r\n\t\t\t\treturn 1; // 1 and 0\r\n\t\t\tcase SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn 5; //true and false\r\n\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 6;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:"
           }

       },

       {
           "id": "clone_184",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "697",
               "end_line": "721",
               "source_code": "        addKeyWord( \"ABS\",      ABS);\r\n        addKeyWord( \"ACOS\",     ACOS);\r\n        addKeyWord( \"ASIN\",     ASIN);\r\n        addKeyWord( \"ATAN\",     ATAN);\r\n        addKeyWord( \"ATN2\",    \tATAN2); //alias for MS SQL Server\r\n        addKeyWord( \"ATAN2\",    ATAN2);\r\n        addKeyWord( \"CEILING\",  CEILING);\r\n        addKeyWord( \"COS\",      COS);\r\n        addKeyWord( \"COT\",      COT);\r\n        addKeyWord( \"DEGREES\",  DEGREES);\r\n        addKeyWord( \"EXP\",      EXP);\r\n        addKeyWord( \"FLOOR\",    FLOOR);\r\n        addKeyWord( \"LOG\",      LOG);\r\n        addKeyWord( \"LOG10\",    LOG10);\r\n        addKeyWord( \"MOD\",      MOD);\r\n        addKeyWord( \"PI\",       PI);\r\n        addKeyWord( \"POWER\",    POWER);\r\n        addKeyWord( \"RADIANS\",  RADIANS);\r\n        addKeyWord( \"RAND\",     RAND);\r\n        addKeyWord( \"ROUND\",    ROUND);\r\n        addKeyWord( \"SIGN\",     SIGN);\r\n        addKeyWord( \"SIN\",      SIN);\r\n        addKeyWord( \"SQRT\",     SQRT);\r\n        addKeyWord( \"TAN\",      TAN);\r\n        addKeyWord( \"TRUNCATE\", TRUNCATE);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "601",
               "end_line": "625",
               "source_code": "        addKeyWord( \"FLOAT\",        FLOAT);\r\n        addKeyWord( \"DOUBLE\",       DOUBLE);\r\n        addKeyWord( \"DATE\",         DATE);\r\n        addKeyWord( \"TIME\",         TIME);\r\n        addKeyWord( \"DATETIME\",     TIMESTAMP); // alias for MS SQL Server data type DATETIME\r\n        addKeyWord( \"TIMESTAMP\",    TIMESTAMP);\r\n        addKeyWord( \"SMALLDATETIME\",SMALLDATETIME);\r\n        addKeyWord( \"CHARACTER\",    CHAR); // alias for CHAR\r\n        addKeyWord( \"CHAR\",         CHAR);\r\n        addKeyWord( \"NCHAR\",        NCHAR);\r\n        addKeyWord( \"VARCHAR2\",     VARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"VARCHAR\",      VARCHAR);\r\n        addKeyWord( \"NVARCHAR2\",    NVARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"NVARCHAR\",     NVARCHAR);\r\n\t\taddKeyWord( \"SYSNAME\",      SYSNAME);\r\n        addKeyWord( \"TEXT\",         LONGVARCHAR);\r\n        addKeyWord( \"LONGVARCHAR\",  LONGVARCHAR);\r\n        addKeyWord( \"NTEXT\",        LONGNVARCHAR);\r\n        addKeyWord( \"LONGNVARCHAR\", LONGNVARCHAR);\r\n        addKeyWord( \"LONG\",         LONG); // alias for Oracle LONG and LONG RAW\r\n        addKeyWord( \"CLOB\",         CLOB);\r\n        addKeyWord( \"NCLOB\",        NCLOB);\r\n        addKeyWord( \"UNIQUEIDENTIFIER\",UNIQUEIDENTIFIER);\r\n        addKeyWord( \"SQL_VARIANT\",  JAVA_OBJECT); // alias for MS SQL Server data type SQL_VARIANT\r\n        addKeyWord( \"JAVA_OBJECT\",  JAVA_OBJECT);"
           }

       },

       {
           "id": "clone_185",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1248",
               "end_line": "1252",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1243",
               "end_line": "1247",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_186",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1428",
               "end_line": "1435",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMPADD:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampAdd( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "1420",
               "end_line": "1427",
               "source_code": "\t\t\tcase SQLTokenizer.TIMESTAMPDIFF:\r\n\t\t\t\ttoken = nextToken(MISSING_INTERVALS);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = expression( cmd, 0);\r\n\t\t\t\tnextToken(MISSING_COMMA);\r\n\t\t\t\texpr = new ExpressionFunctionTimestampDiff( token.value, expr, expression( cmd, 0));\r\n\t\t\t\tnextToken(MISSING_PARENTHESIS_R);\r\n\t\t\t\treturn expr;"
           }

       },

       {
           "id": "clone_187",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "870",
               "end_line": "881",
               "source_code": "            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2int( readLongBinary() ) != 0;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp() != 0;\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime() != 0;\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate() != 0;\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime() != 0;\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "833",
               "end_line": "844",
               "source_code": "            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2int( readBinary() ) != 0;\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() != 0;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() != 0;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_188",

           "clone_type": "type-2",

           "origin": {
               "file": "Utils.java",
               "start_line": "248",
               "end_line": "256",
               "source_code": "        daten[8] = hex2byte( chars, 19 );\r\n        daten[9] = hex2byte( chars, 21 );\r\n\r\n        daten[10] = hex2byte( chars, 24 );\r\n        daten[11] = hex2byte( chars, 26 );\r\n        daten[12] = hex2byte( chars, 28 );\r\n        daten[13] = hex2byte( chars, 30 );\r\n        daten[14] = hex2byte( chars, 32 );\r\n        daten[15] = hex2byte( chars, 34 );"
           },

           "clone": {
               "file": "Utils.java",
               "start_line": "237",
               "end_line": "246",
               "source_code": "        daten[3] = hex2byte( chars, 0 );\r\n        daten[2] = hex2byte( chars, 2 );\r\n        daten[1] = hex2byte( chars, 4 );\r\n        daten[0] = hex2byte( chars, 6 );\r\n\r\n        daten[5] = hex2byte( chars, 9 );\r\n        daten[4] = hex2byte( chars, 11 );\r\n\r\n        daten[7] = hex2byte( chars, 14 );\r\n        daten[6] = hex2byte( chars, 16 );"
           }

       },

       {
           "id": "clone_189",

           "clone_type": "type-2",

           "origin": {
               "file": "IndexDescription.java",
               "start_line": "171",
               "end_line": "178",
               "source_code": "            if(!file.exists())\r\n                throw SmallSQLException.create(Language.INDEX_MISSING, name);\r\n            raFile = Utils.openRaFile( file, database.isReadOnly() );\r\n            ByteBuffer buffer = ByteBuffer.allocate(8);\r\n            raFile.read(buffer);\r\n            buffer.position(0);\r\n            int magic   = buffer.getInt();\r\n            int version = buffer.getInt();"
           },

           "clone": {
               "file": "TableView.java",
               "start_line": "83",
               "end_line": "90",
               "source_code": "\t\t\tif(!file.exists())\r\n\t\t\t\tthrow SmallSQLException.create(Language.TABLE_OR_VIEW_MISSING, name);\r\n\t\t\traFile = Utils.openRaFile( file, database.isReadOnly() );\r\n\t\t\tByteBuffer buffer = ByteBuffer.allocate(8);\r\n\t\t\traFile.read(buffer);\r\n\t\t\tbuffer.position(0);\r\n\t\t\tint magic   = buffer.getInt();\r\n\t\t\tint version = buffer.getInt();"
           }

       },

       {
           "id": "clone_190",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "173",
               "end_line": "188",
               "source_code": "\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\t\treturn 7;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n            case SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "130",
               "end_line": "145",
               "source_code": "\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:\r\n                return 13;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 17;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.BLOB:\r\n            case SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_191",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "141",
               "end_line": "150",
               "source_code": "                case '/':\r\n                case '%':\r\n                case '&':\r\n                case '|':\r\n                case '=':\r\n                case '<':\r\n                case '>':\r\n                case '?':\r\n                case '^':\r\n                case '~':"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "131",
               "end_line": "140",
               "source_code": "\t\t\t\tcase '\\t':\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\tcase '\\r':\r\n                case ',':\r\n                case '(':\r\n                case ')':\r\n                case '{':\r\n                case '}':\r\n                case '*':\r\n                case '+':"
           }

       },

       {
           "id": "clone_192",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "110",
               "end_line": "114",
               "source_code": "\t\t\tcase SQLTokenizer.BINARY:\r\n\t\t\tcase SQLTokenizer.VARBINARY:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:\r\n\t\t\tcase SQLTokenizer.BLOB:\r\n\t\t\t\treturn true;"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "93",
               "end_line": "97",
               "source_code": "\t\t\tcase SQLTokenizer.NUMERIC:\r\n\t\t\tcase SQLTokenizer.REAL:\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn true;"
           }

       },

       {
           "id": "clone_193",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1247",
               "end_line": "1251",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return new MutableNumeric( readLongString() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1242",
               "end_line": "1246",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return new MutableNumeric( readString() );"
           }

       },

       {
           "id": "clone_194",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "520",
               "end_line": "525",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "495",
               "end_line": "500",
               "source_code": "            case SQLTokenizer.BIT:\r\n                return (obj.equals(Boolean.TRUE)) ? 1 : 0;\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n\t\t\tcase SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_195",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "277",
               "end_line": "282",
               "source_code": "            case Types.REAL:\r\n                    return \"java.lang.Float\";\r\n            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                    return \"java.lang.Double\";\r\n            case Types.DATE:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "261",
               "end_line": "266",
               "source_code": "            case Types.INTEGER:\r\n                    return \"java.lang.Integer\";\r\n            case Types.BIT:\r\n            case Types.BOOLEAN:\r\n                    return \"java.lang.Boolean\";\r\n            case Types.BINARY:"
           }

       },

       {
           "id": "clone_196",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "930",
               "end_line": "934",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Integer.parseInt( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "925",
               "end_line": "929",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Integer.parseInt( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_197",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "98",
               "end_line": "104",
               "source_code": "            case 'M':\r\n            case 'N':\r\n                c = '5';\r\n                break;\r\n            case 'R':\r\n                c = '6';\r\n                break;"
           },

           "clone": {
               "file": "ExpressionFunctionSoundex.java",
               "start_line": "91",
               "end_line": "97",
               "source_code": "            case 'D':\r\n            case 'T':\r\n                c = '3';\r\n                break;\r\n            case 'L':\r\n                c = '4';\r\n                break;"
           }

       },

       {
           "id": "clone_198",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "205",
               "end_line": "209",
               "source_code": "\t\t\tcase SQLTokenizer.UNIQUEIDENTIFIER:\r\n\t\t\t\treturn 36;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARBINARY:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "181",
               "end_line": "185",
               "source_code": "\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 15;\r\n            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n\t\t\tcase SQLTokenizer.VARCHAR:"
           }

       },

       {
           "id": "clone_199",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "786",
               "end_line": "792",
               "source_code": "\t        case OR:\r\n\t        case AND:\r\n\t        case NOT:\r\n\t        case LIKE:\r\n\t        case ISNULL:\r\n\t\t\tcase ISNOTNULL:\r\n\t\t\tcase IN:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "747",
               "end_line": "753",
               "source_code": "\t\t\tcase BETWEEN:\r\n\t\t\tcase OR:\r\n\t\t\tcase AND:\r\n\t\t\tcase NOT:\r\n\t\t\tcase LIKE:\r\n\t\t\tcase ISNULL:\r\n\t\t\tcase ISNOTNULL:"
           }

       },

       {
           "id": "clone_200",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "888",
               "end_line": "898",
               "source_code": "            case SQLTokenizer.BETWEEN:      return BETWEEN;\r\n            case SQLTokenizer.LIKE:         return LIKE;\r\n            case SQLTokenizer.IN:           return IN;\r\n\t\t\tcase SQLTokenizer.IS:           return ISNULL;\r\n            case SQLTokenizer.OR:           return OR;\r\n            case SQLTokenizer.AND:          return AND;\r\n            case SQLTokenizer.NOT:          return NOT;\r\n            case SQLTokenizer.BIT_OR:       return BIT_OR;\r\n            case SQLTokenizer.BIT_AND:      return BIT_AND;\r\n            case SQLTokenizer.BIT_XOR:      return BIT_XOR;\r\n            case SQLTokenizer.TILDE:        return BIT_NOT;"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "877",
               "end_line": "887",
               "source_code": "            case SQLTokenizer.PLUS:         return ADD;\r\n            case SQLTokenizer.MINUS:        return SUB;\r\n            case SQLTokenizer.ASTERISK:     return MUL;\r\n            case SQLTokenizer.SLACH:        return DIV;\r\n            case SQLTokenizer.PERCENT:      return MOD;\r\n            case SQLTokenizer.EQUALS:       return EQUALS;\r\n            case SQLTokenizer.GREATER:      return GREATER;\r\n            case SQLTokenizer.GREATER_EQU:  return GRE_EQU;\r\n            case SQLTokenizer.LESSER:       return LESSER;\r\n            case SQLTokenizer.LESSER_EQU:   return LES_EQU;\r\n            case SQLTokenizer.UNEQUALS:     return UNEQUALS;"
           }

       },

       {
           "id": "clone_201",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionReturnP1Number.java",
               "start_line": "62",
               "end_line": "66",
               "source_code": "\t\t\tcase SQLTokenizer.INT:\r\n\t\t\t\treturn new MutableNumeric(getInt());\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\t\treturn new MutableNumeric(getLong());\r\n\t\t\tcase SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1290",
               "end_line": "1294",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_202",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1186",
               "end_line": "1190",
               "source_code": "\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Money.parseMoney( readLongString() );"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1181",
               "end_line": "1185",
               "source_code": "            case SQLTokenizer.CHAR:\r\n            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Money.parseMoney( readString() );"
           }

       },

       {
           "id": "clone_203",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1411",
               "end_line": "1416",
               "source_code": "            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return readBinary();\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1373",
               "end_line": "1378",
               "source_code": "            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return readString();\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:"
           }

       },

       {
           "id": "clone_204",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "408",
               "end_line": "421",
               "source_code": "\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 104: // german dd.mm.yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 5: // italiano dd-mm-yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "394",
               "end_line": "407",
               "source_code": "\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year % 100, 2, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 103: // britsh dd/mm/yyyy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('/');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\treturn buf.toString();\r\n\t\t\tcase 4: // german dd.mm.yy\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);"
           }

       },

       {
           "id": "clone_205",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1454",
               "end_line": "1458",
               "source_code": "            case SQLTokenizer.JAVA_OBJECT:\r\n            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return readLongBinary();\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1377",
               "end_line": "1381",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return readLongString();\r\n            case SQLTokenizer.JAVA_OBJECT:"
           }

       },

       {
           "id": "clone_206",

           "clone_type": "type-2",

           "origin": {
               "file": "Identity.java",
               "start_line": "71",
               "end_line": "78",
               "source_code": "\t\tpage[ 0 ] = (byte)(value >> 56);\r\n\t\tpage[ 1 ] = (byte)(value >> 48);\r\n\t\tpage[ 2 ] = (byte)(value >> 40);\r\n\t\tpage[ 3 ] = (byte)(value >> 32);\r\n\t\tpage[ 4 ] = (byte)(value >> 24);\r\n\t\tpage[ 5 ] = (byte)(value >> 16);\r\n\t\tpage[ 6 ] = (byte)(value >> 8);\r\n\t\tpage[ 7 ] = (byte)(value);"
           },

           "clone": {
               "file": "Utils.java",
               "start_line": "179",
               "end_line": "186",
               "source_code": "        result[0] = (byte)(value >> 56);\r\n        result[1] = (byte)(value >> 48);\r\n        result[2] = (byte)(value >> 40);\r\n        result[3] = (byte)(value >> 32);\r\n        result[4] = (byte)(value >> 24);\r\n        result[5] = (byte)(value >> 16);\r\n        result[6] = (byte)(value >> 8);\r\n        result[7] = (byte)(value);"
           }

       },

       {
           "id": "clone_207",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1133",
               "end_line": "1143",
               "source_code": "            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2double( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1096",
               "end_line": "1106",
               "source_code": "            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2double( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();"
           }

       },

       {
           "id": "clone_208",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "848",
               "end_line": "854",
               "source_code": "                    return readDouble() != 0;\r\n            case SQLTokenizer.MONEY:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.SMALLMONEY:\r\n                    return readInt() != 0;\r\n            case SQLTokenizer.NUMERIC:\r\n            case SQLTokenizer.DECIMAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "841",
               "end_line": "847",
               "source_code": "                    return readInt() != 0;\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong() != 0;\r\n            case SQLTokenizer.REAL:\r\n                    return readFloat() != 0;\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:"
           }

       },

       {
           "id": "clone_209",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1259",
               "end_line": "1265",
               "source_code": "            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n                    throw SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"NUMERIC\" });\r\n            // SAVER: check if this should be a kind of \"type not recognized\" exception.\r\n            default: throw new Error();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1198",
               "end_line": "1203",
               "source_code": "            case SQLTokenizer.TIMESTAMP:\r\n            case SQLTokenizer.TIME:\r\n            case SQLTokenizer.DATE:\r\n            case SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\tthrow SmallSQLException.create(Language.VALUE_CANT_CONVERT, new Object[] { SQLTokenizer.getKeyWord(dataType), \"MONEY\" });\r\n            default: throw new Error();"
           }

       },

       {
           "id": "clone_210",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionValue.java",
               "start_line": "461",
               "end_line": "469",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.DOUBLE:\r\n            case SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "ExpressionValue.java",
               "start_line": "426",
               "end_line": "434",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                return (obj == Boolean.TRUE) ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:\r\n            case SQLTokenizer.BIGINT:\r\n            case SQLTokenizer.REAL:\r\n            case SQLTokenizer.FLOAT:"
           }

       },

       {
           "id": "clone_211",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "862",
               "end_line": "866",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Utils.string2boolean( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "857",
               "end_line": "861",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Utils.string2boolean( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_212",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "597",
               "end_line": "603",
               "source_code": "\t\t\tcase 130: // Kuwaiti  dd mon yyyy hh:mi:ss:mmmAM\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "526",
               "end_line": "532",
               "source_code": "\t\t\tcase 113: // default + millis;  dd mon yyyy hh:mm:ss:mmm(24h)\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tbuf.append( SHORT_MONTHS[ details.month ]);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append(' ');"
           }

       },

       {
           "id": "clone_213",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1155",
               "end_line": "1159",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1093",
               "end_line": "1097",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n                    return readBoolean() ? 1 : 0;\r\n            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:"
           }

       },

       {
           "id": "clone_214",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "168",
               "end_line": "176",
               "source_code": "\t\t\tcase SQLTokenizer.TINYINT:\r\n\t\t\t\treturn 3;\r\n\t\t\tcase SQLTokenizer.SMALLINT:\r\n\t\t\t\treturn 5;\r\n\t\t\tcase SQLTokenizer.INT:\r\n\t\t\tcase SQLTokenizer.SMALLMONEY:\r\n\t\t\t\treturn 10;\r\n\t\t\tcase SQLTokenizer.BIGINT:\r\n\t\t\tcase SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "133",
               "end_line": "141",
               "source_code": "            case SQLTokenizer.MONEY:\r\n\t\t\t\treturn 19;\r\n            case SQLTokenizer.REAL:\r\n                return 13;\r\n\t\t\tcase SQLTokenizer.FLOAT:\r\n\t\t\tcase SQLTokenizer.DOUBLE:\r\n\t\t\t\treturn 17;\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n            case SQLTokenizer.LONGNVARCHAR:"
           }

       },

       {
           "id": "clone_215",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1163",
               "end_line": "1167",
               "source_code": "            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:\r\n                    return readInt() * 10000L;\r\n            case SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "357",
               "end_line": "361",
               "source_code": "            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_216",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionFunctionConvert.java",
               "start_line": "177",
               "end_line": "182",
               "source_code": "\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getDateTimeLong(), dataType );\r\n\t\t\tcase SQLTokenizer.NUMERIC:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "518",
               "end_line": "523",
               "source_code": "\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\treturn new DateTime( getLong(), dataType );\r\n            case SQLTokenizer.UNIQUEIDENTIFIER:"
           }

       },

       {
           "id": "clone_217",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1290",
               "end_line": "1297",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return new Long(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( readFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( readDouble() );\r\n            case SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1228",
               "end_line": "1235",
               "source_code": "            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:"
           }

       },

       {
           "id": "clone_218",

           "clone_type": "type-2",

           "origin": {
               "file": "ExpressionArithmetic.java",
               "start_line": "352",
               "end_line": "357",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 10000 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "312",
               "end_line": "317",
               "source_code": "            case SQLTokenizer.BIT:\r\n            case SQLTokenizer.BOOLEAN:\r\n\t\t\t\treturn getBoolean() ? 1 : 0;\r\n            case SQLTokenizer.TINYINT:\r\n            case SQLTokenizer.SMALLINT:\r\n            case SQLTokenizer.INT:"
           }

       },

       {
           "id": "clone_219",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "338",
               "end_line": "346",
               "source_code": "\t\t\tcase SQLTokenizer.NVARCHAR:\r\n\t\t\t\t\t\treturn Types.VARCHAR;\r\n\t\t\tcase SQLTokenizer.LONGNVARCHAR:\r\n\t\t\tcase SQLTokenizer.LONGVARCHAR:\r\n\t\t\t\t\t\treturn Types.LONGVARCHAR;\r\n\t\t\tcase SQLTokenizer.CLOB:\r\n\t\t\tcase SQLTokenizer.NCLOB:\r\n\t\t\t\t\t\treturn Types.CLOB;\r\n\t\t\tcase SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "329",
               "end_line": "337",
               "source_code": "\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\t\treturn Types.TIME;\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\t\treturn Types.TIMESTAMP;\r\n\t\t\tcase SQLTokenizer.CHAR:\r\n\t\t\tcase SQLTokenizer.NCHAR:\r\n\t\t\t\t\t\treturn Types.CHAR;\r\n\t\t\tcase SQLTokenizer.VARCHAR:"
           }

       },

       {
           "id": "clone_220",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1157",
               "end_line": "1169",
               "source_code": "                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:\r\n                case SQLTokenizer.AND:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "276",
               "end_line": "288",
               "source_code": "    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:"
           }

       },

       {
           "id": "clone_221",

           "clone_type": "type-2",

           "origin": {
               "file": "SSResultSetMetaData.java",
               "start_line": "279",
               "end_line": "286",
               "source_code": "            case Types.FLOAT:\r\n            case Types.DOUBLE:\r\n                    return \"java.lang.Double\";\r\n            case Types.DATE:\r\n                    return \"java.sql.Date\";\r\n            case Types.TIME:\r\n                    return \"java.sql.Time\";\r\n            case Types.TIMESTAMP:"
           },

           "clone": {
               "file": "SSResultSetMetaData.java",
               "start_line": "267",
               "end_line": "274",
               "source_code": "            case Types.VARBINARY:\r\n            case Types.LONGVARBINARY:\r\n                    return \"[B\";\r\n            case Types.BLOB:\r\n                    return \"java.sql.Blob\";\r\n            case Types.BIGINT:\r\n                    return \"java.lang.Long\";\r\n            case Types.DECIMAL:"
           }

       },

       {
           "id": "clone_222",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLParser.java",
               "start_line": "1156",
               "end_line": "1168",
               "source_code": "                case SQLTokenizer.PLUS:\r\n                case SQLTokenizer.MINUS:\r\n                case SQLTokenizer.ASTERISK:\r\n                case SQLTokenizer.SLACH:\r\n                case SQLTokenizer.PERCENT:\r\n                case SQLTokenizer.EQUALS:\r\n                case SQLTokenizer.LESSER:\r\n                case SQLTokenizer.LESSER_EQU:\r\n                case SQLTokenizer.GREATER:\r\n                case SQLTokenizer.GREATER_EQU:\r\n                case SQLTokenizer.UNEQUALS:\r\n                case SQLTokenizer.LIKE:\r\n                case SQLTokenizer.OR:"
           },

           "clone": {
               "file": "SQLParser.java",
               "start_line": "276",
               "end_line": "288",
               "source_code": "    \t\tcase SQLTokenizer.SELECT:\r\n    \t\tcase SQLTokenizer.INSERT:\r\n    \t\tcase SQLTokenizer.UPDATE:\r\n    \t\tcase SQLTokenizer.UNION:\r\n    \t\tcase SQLTokenizer.FROM:\r\n    \t\tcase SQLTokenizer.WHERE:\r\n    \t\tcase SQLTokenizer.GROUP:\r\n    \t\tcase SQLTokenizer.HAVING:\r\n\t\t\tcase SQLTokenizer.ORDER:\r\n    \t\tcase SQLTokenizer.COMMA:\r\n\t\t\tcase SQLTokenizer.SET:\r\n            case SQLTokenizer.JOIN:\r\n            case SQLTokenizer.LIMIT:"
           }

       },

       {
           "id": "clone_223",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1226",
               "end_line": "1235",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return new MutableNumeric(readInt());\r\n            case SQLTokenizer.BIGINT:\r\n                    return new MutableNumeric(readLong());\r\n            case SQLTokenizer.REAL:\r\n                    return new MutableNumeric(readFloat());\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new MutableNumeric(readDouble());\r\n            case SQLTokenizer.MONEY:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "486",
               "end_line": "495",
               "source_code": "            case SQLTokenizer.INT:\r\n                    return new Integer( getInt() );\r\n            case SQLTokenizer.BIGINT:\r\n                    return new Long( getLong() );\r\n            case SQLTokenizer.REAL:\r\n                    return new Float( getFloat() );\r\n            case SQLTokenizer.FLOAT:\r\n            case SQLTokenizer.DOUBLE:\r\n                    return new Double( getDouble() );\r\n            case SQLTokenizer.MONEY:"
           }

       },

       {
           "id": "clone_224",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "899",
               "end_line": "916",
               "source_code": "\t\taddKeyWord( \"SQL_BIGINT\",\t\tSQL_BIGINT);\r\n\t\taddKeyWord( \"SQL_BINARY\",\t\tSQL_BINARY);\r\n\t\taddKeyWord( \"SQL_BIT\",\t\t\tSQL_BIT);\r\n\t\taddKeyWord( \"SQL_CHAR\",\t\t\tSQL_CHAR);\r\n\t\taddKeyWord( \"SQL_DATE\",\t\t\tSQL_DATE);\r\n\t\taddKeyWord( \"SQL_DECIMAL\",\t\tSQL_DECIMAL);\r\n\t\taddKeyWord( \"SQL_DOUBLE\",\t\tSQL_DOUBLE);\r\n\t\taddKeyWord( \"SQL_FLOAT\",\t\tSQL_FLOAT);\r\n\t\taddKeyWord( \"SQL_INTEGER\",\t\tSQL_INTEGER);\r\n\t\taddKeyWord( \"SQL_LONGVARBINARY\",SQL_LONGVARBINARY);\r\n\t\taddKeyWord( \"SQL_LONGVARCHAR\",\tSQL_LONGVARCHAR);\r\n\t\taddKeyWord( \"SQL_REAL\",\t\t\tSQL_REAL);\r\n\t\taddKeyWord( \"SQL_SMALLINT\",\t\tSQL_SMALLINT);\r\n\t\taddKeyWord( \"SQL_TIME\",\t\t\tSQL_TIME);\r\n\t\taddKeyWord( \"SQL_TIMESTAMP\",\tSQL_TIMESTAMP);\r\n\t\taddKeyWord( \"SQL_TINYINT\",\t\tSQL_TINYINT);\r\n\t\taddKeyWord( \"SQL_VARBINARY\",\tSQL_VARBINARY);\r\n\t\taddKeyWord( \"SQL_VARCHAR\",\t\tSQL_VARCHAR);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "842",
               "end_line": "860",
               "source_code": "\t\taddKeyWord( \"N\",\t\t\t\t\tSQL_TSI_MINUTE);\r\n\t\taddKeyWord( \"SQL_TSI_MINUTE\",\t\tSQL_TSI_MINUTE);\r\n\t\taddKeyWord( \"HH\",\t\t\t\t\tSQL_TSI_HOUR);\r\n\t\taddKeyWord( \"SQL_TSI_HOUR\",\t\t\tSQL_TSI_HOUR);\r\n\t\t//addKeyWord( \"D\",\t\t\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"DD\",\t\t\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"SQL_TSI_DAY\",\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"WK\",\t\t\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"WW\",\t\t\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"SQL_TSI_WEEK\",\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"M\",\t\t\t\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"MM\",\t\t\t\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"SQL_TSI_MONTH\",\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"Q\",\t\t\t\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"QQ\",\t\t\t\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"SQL_TSI_QUARTER\",\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"YY\",\t\t\t\t\tSQL_TSI_YEAR);\r\n\t\taddKeyWord( \"YYYY\",\t\t\t\t\tSQL_TSI_YEAR);\r\n\t\taddKeyWord( \"SQL_TSI_YEAR\",\t\t\tSQL_TSI_YEAR);"
           }

       },

       {
           "id": "clone_225",

           "clone_type": "type-2",

           "origin": {
               "file": "DateTime.java",
               "start_line": "581",
               "end_line": "596",
               "source_code": "\t\t\tcase 26:\r\n\t\t\tcase 126: // ISO8601; yyyy-mm-ddThh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append('T');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();"
           },

           "clone": {
               "file": "DateTime.java",
               "start_line": "565",
               "end_line": "580",
               "source_code": "\t\t\tcase 21:\r\n\t\t\tcase 121: // ODBC kannonish + millis; yyyy-mm-dd hh:mi:ss.mmm(24h)\r\n\t\t\t\tformatNumber( details.year, 4, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.month+1, 2, buf);\r\n\t\t\t\tbuf.append('-');\r\n\t\t\t\tformatNumber( details.day, 2, buf);\r\n\t\t\t\tbuf.append(' ');\r\n\t\t\t\tformatNumber( details.hour, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.minute, 2, buf);\r\n\t\t\t\tbuf.append(':');\r\n\t\t\t\tformatNumber( details.second, 2, buf);\r\n\t\t\t\tbuf.append('.');\r\n\t\t\t\tformatMillis( details.millis, buf );\r\n\t\t\t\treturn buf.toString();"
           }

       },

       {
           "id": "clone_226",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1477",
               "end_line": "1482",
               "source_code": "                    break;\r\n                case SQLTokenizer.SMALLINT:\r\n                    offset += 2;\r\n                    break;\r\n                case SQLTokenizer.INT:\r\n                case SQLTokenizer.REAL:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "707",
               "end_line": "712",
               "source_code": "                    break;\r\n                case SQLTokenizer.UNIQUEIDENTIFIER:\r\n                    offset += 16;\r\n                    break;\r\n                case SQLTokenizer.NUMERIC:\r\n                case SQLTokenizer.DECIMAL:"
           }

       },

       {
           "id": "clone_227",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1161",
               "end_line": "1165",
               "source_code": "            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte() * 10000L;\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort() * 10000L;\r\n            case SQLTokenizer.INT:"
           },

           "clone": {
               "file": "ExpressionArithmetic.java",
               "start_line": "357",
               "end_line": "361",
               "source_code": "            case SQLTokenizer.INT:\r\n\t\t\t\treturn getIntImpl() * 10000;\r\n            case SQLTokenizer.BIGINT:\r\n                return getLongImpl() * 10000;\r\n\t\t\tcase SQLTokenizer.REAL:"
           }

       },

       {
           "id": "clone_228",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1060",
               "end_line": "1064",
               "source_code": "\t\t\tcase SQLTokenizer.NCLOB:\r\n            case SQLTokenizer.LONGNVARCHAR:\r\n            case SQLTokenizer.LONGVARCHAR:\r\n                    return Float.parseFloat( readLongString() );\r\n            case SQLTokenizer.JAVA_OBJECT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "1055",
               "end_line": "1059",
               "source_code": "            case SQLTokenizer.NCHAR:\r\n            case SQLTokenizer.VARCHAR:\r\n            case SQLTokenizer.NVARCHAR:\r\n                    return Float.parseFloat( readString() );\r\n\t\t\tcase SQLTokenizer.CLOB:"
           }

       },

       {
           "id": "clone_229",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "1003",
               "end_line": "1013",
               "source_code": "            case SQLTokenizer.LONGVARBINARY:\r\n            case SQLTokenizer.BLOB:\r\n                    return Utils.bytes2long( readLongBinary() );\r\n\t\t\tcase SQLTokenizer.TIMESTAMP:\r\n\t\t\t\t\treturn readTimestamp();\r\n\t\t\tcase SQLTokenizer.TIME:\r\n\t\t\t\t\treturn readTime();\r\n\t\t\tcase SQLTokenizer.DATE:\r\n\t\t\t\t\treturn readDate();\r\n\t\t\tcase SQLTokenizer.SMALLDATETIME:\r\n\t\t\t\t\treturn readSmallDateTime();"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "966",
               "end_line": "976",
               "source_code": "            case SQLTokenizer.BINARY:\r\n            case SQLTokenizer.VARBINARY:\r\n                    return Utils.bytes2long( readBinary() );\r\n            case SQLTokenizer.TINYINT:\r\n                    return readUnsignedByte();\r\n            case SQLTokenizer.SMALLINT:\r\n                    return readShort();\r\n            case SQLTokenizer.INT:\r\n                    return readInt();\r\n            case SQLTokenizer.BIGINT:\r\n                    return readLong();"
           }

       },

       {
           "id": "clone_230",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "581",
               "end_line": "625",
               "source_code": "        addKeyWord( \"VARBINARY\",    VARBINARY);\r\n\t\taddKeyWord( \"RAW\",          RAW); // alias for Oracle RAW and LONG RAW\r\n\t\taddKeyWord( \"IMAGE\",        LONGVARBINARY); // alias for MS SQL Server data type IMAGE\r\n        addKeyWord( \"LONGVARBINARY\",LONGVARBINARY);\r\n        addKeyWord( \"BLOB\",         BLOB);\r\n        addKeyWord( \"BYTE\",         TINYINT);\r\n        addKeyWord( \"TINYINT\",      TINYINT);\r\n        addKeyWord( \"SMALLINT\",     SMALLINT);\r\n\t\taddKeyWord( \"INTEGER\",      INT);\r\n        addKeyWord( \"INT\",          INT);\r\n        addKeyWord( \"SERIAL\",       COUNTER); //alias for MySQL and PostgreSQL\r\n        addKeyWord( \"COUNTER\",      COUNTER);\r\n        addKeyWord( \"BIGINT\",       BIGINT);\r\n        addKeyWord( \"SMALLMONEY\",   SMALLMONEY);\r\n        addKeyWord( \"MONEY\",        MONEY);\r\n\t\taddKeyWord( \"NUMBER\",       DECIMAL);\r\n\t\taddKeyWord( \"VARNUM\",       DECIMAL);\r\n\t\taddKeyWord( \"DECIMAL\",      DECIMAL);\r\n        addKeyWord( \"NUMERIC\",      NUMERIC);\r\n        addKeyWord( \"REAL\",         REAL);\r\n        addKeyWord( \"FLOAT\",        FLOAT);\r\n        addKeyWord( \"DOUBLE\",       DOUBLE);\r\n        addKeyWord( \"DATE\",         DATE);\r\n        addKeyWord( \"TIME\",         TIME);\r\n        addKeyWord( \"DATETIME\",     TIMESTAMP); // alias for MS SQL Server data type DATETIME\r\n        addKeyWord( \"TIMESTAMP\",    TIMESTAMP);\r\n        addKeyWord( \"SMALLDATETIME\",SMALLDATETIME);\r\n        addKeyWord( \"CHARACTER\",    CHAR); // alias for CHAR\r\n        addKeyWord( \"CHAR\",         CHAR);\r\n        addKeyWord( \"NCHAR\",        NCHAR);\r\n        addKeyWord( \"VARCHAR2\",     VARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"VARCHAR\",      VARCHAR);\r\n        addKeyWord( \"NVARCHAR2\",    NVARCHAR); // alias for Oracle VARCHAR2\r\n        addKeyWord( \"NVARCHAR\",     NVARCHAR);\r\n\t\taddKeyWord( \"SYSNAME\",      SYSNAME);\r\n        addKeyWord( \"TEXT\",         LONGVARCHAR);\r\n        addKeyWord( \"LONGVARCHAR\",  LONGVARCHAR);\r\n        addKeyWord( \"NTEXT\",        LONGNVARCHAR);\r\n        addKeyWord( \"LONGNVARCHAR\", LONGNVARCHAR);\r\n        addKeyWord( \"LONG\",         LONG); // alias for Oracle LONG and LONG RAW\r\n        addKeyWord( \"CLOB\",         CLOB);\r\n        addKeyWord( \"NCLOB\",        NCLOB);\r\n        addKeyWord( \"UNIQUEIDENTIFIER\",UNIQUEIDENTIFIER);\r\n        addKeyWord( \"SQL_VARIANT\",  JAVA_OBJECT); // alias for MS SQL Server data type SQL_VARIANT\r\n        addKeyWord( \"JAVA_OBJECT\",  JAVA_OBJECT);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "488",
               "end_line": "536",
               "source_code": "        addKeyWord( \"VALUES\",   VALUES);\r\n        addKeyWord( \"AS\",       AS);\r\n        addKeyWord( \"DEFAULT\",  DEFAULT);\r\n        addKeyWord( \"AUTO_INCREMENT\", IDENTITY); // alias for IDENTITY; alias must set first so that key is in the hashtable and not the alias\r\n        addKeyWord( \"IDENTITY\", IDENTITY);\r\n        addKeyWord( \"INNER\",    INNER);\r\n        addKeyWord( \"JOIN\",     JOIN);\r\n        addKeyWord( \"ON\",       ON);\r\n        addKeyWord( \"OUTER\",    OUTER);\r\n        addKeyWord( \"FULL\",     FULL);\r\n        addKeyWord( \"CROSS\",    CROSS);\r\n\t\taddKeyWord( \"USE\",      USE);\r\n\t\taddKeyWord( \"TOP\",      TOP);\r\n\t\taddKeyWord( \"ADD\",      ADD);\r\n        addKeyWord( \"LIMIT\",    LIMIT);\r\n\r\n        addKeyWord( \"DATABASE\", DATABASE);\r\n        addKeyWord( \"TABLE\",    TABLE);\r\n        addKeyWord( \"VIEW\",     VIEW);\r\n        addKeyWord( \"INDEX\",    INDEX);\r\n        addKeyWord( \"PROCEDURE\",PROCEDURE);\r\n\r\n        addKeyWord( \"TRANSACTION\",  TRANSACTION);\r\n        addKeyWord( \"ISOLATION\",    ISOLATION);\r\n        addKeyWord( \"LEVEL\",        LEVEL);\r\n        addKeyWord( \"READ\",         READ);\r\n        addKeyWord( \"COMMITTED\",    COMMITTED);\r\n        addKeyWord( \"UNCOMMITTED\",  UNCOMMITTED);\r\n        addKeyWord( \"REPEATABLE\",   REPEATABLE);\r\n        addKeyWord( \"SERIALIZABLE\", SERIALIZABLE);\r\n        \r\n\t\taddKeyWord( \"CONSTRAINT\", \tCONSTRAINT);\r\n\t\taddKeyWord( \"PRIMARY\",    \tPRIMARY);\r\n\t\taddKeyWord( \"FOREIGN\",     \tFOREIGN);\r\n\t\taddKeyWord( \"KEY\",    \t\tKEY);\r\n\t\taddKeyWord( \"UNIQUE\",\t\tUNIQUE);\r\n\t\taddKeyWord( \"CLUSTERED\",  \tCLUSTERED);\r\n\t\taddKeyWord( \"NONCLUSTERED\", NONCLUSTERED);\r\n\t\taddKeyWord( \"REFERENCES\",   REFERENCES);\r\n\r\n\t\taddKeyWord( \"UNION\", \t\tUNION);\r\n\t\taddKeyWord( \"ALL\",   \t\tALL);\r\n\t\taddKeyWord( \"DISTINCT\",   \tDISTINCT);\r\n\t\taddKeyWord( \"CASE\",   \t\tCASE);\r\n\t\taddKeyWord( \"WHEN\",   \t\tWHEN);\r\n\t\taddKeyWord( \"THEN\",   \t\tTHEN);\r\n\t\taddKeyWord( \"ELSE\",   \t\tELSE);\r\n\t\taddKeyWord( \"END\",   \t\tEND);\r\n\t\taddKeyWord( \"SWITCH\", \t\tSWITCH);"
           }

       },

       {
           "id": "clone_231",

           "clone_type": "type-2",

           "origin": {
               "file": "SQLTokenizer.java",
               "start_line": "836",
               "end_line": "860",
               "source_code": "\t\taddKeyWord( \"MS\",\t\t\t\t\tSQL_TSI_FRAC_SECOND);\r\n\t\taddKeyWord( \"SQL_TSI_FRAC_SECOND\",\tSQL_TSI_FRAC_SECOND);\r\n\t\taddKeyWord( \"S\",\t\t\t\t\tSQL_TSI_SECOND);\r\n\t\taddKeyWord( \"SS\",\t\t\t\t\tSQL_TSI_SECOND);\r\n\t\taddKeyWord( \"SQL_TSI_SECOND\",\t\tSQL_TSI_SECOND);\r\n\t\taddKeyWord( \"MI\",\t\t\t\t\tSQL_TSI_MINUTE);\r\n\t\taddKeyWord( \"N\",\t\t\t\t\tSQL_TSI_MINUTE);\r\n\t\taddKeyWord( \"SQL_TSI_MINUTE\",\t\tSQL_TSI_MINUTE);\r\n\t\taddKeyWord( \"HH\",\t\t\t\t\tSQL_TSI_HOUR);\r\n\t\taddKeyWord( \"SQL_TSI_HOUR\",\t\t\tSQL_TSI_HOUR);\r\n\t\t//addKeyWord( \"D\",\t\t\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"DD\",\t\t\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"SQL_TSI_DAY\",\t\t\tSQL_TSI_DAY);\r\n\t\taddKeyWord( \"WK\",\t\t\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"WW\",\t\t\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"SQL_TSI_WEEK\",\t\t\tSQL_TSI_WEEK);\r\n\t\taddKeyWord( \"M\",\t\t\t\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"MM\",\t\t\t\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"SQL_TSI_MONTH\",\t\tSQL_TSI_MONTH);\r\n\t\taddKeyWord( \"Q\",\t\t\t\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"QQ\",\t\t\t\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"SQL_TSI_QUARTER\",\t\tSQL_TSI_QUARTER);\r\n\t\taddKeyWord( \"YY\",\t\t\t\t\tSQL_TSI_YEAR);\r\n\t\taddKeyWord( \"YYYY\",\t\t\t\t\tSQL_TSI_YEAR);\r\n\t\taddKeyWord( \"SQL_TSI_YEAR\",\t\t\tSQL_TSI_YEAR);"
           },

           "clone": {
               "file": "SQLTokenizer.java",
               "start_line": "698",
               "end_line": "721",
               "source_code": "        addKeyWord( \"ACOS\",     ACOS);\r\n        addKeyWord( \"ASIN\",     ASIN);\r\n        addKeyWord( \"ATAN\",     ATAN);\r\n        addKeyWord( \"ATN2\",    \tATAN2); //alias for MS SQL Server\r\n        addKeyWord( \"ATAN2\",    ATAN2);\r\n        addKeyWord( \"CEILING\",  CEILING);\r\n        addKeyWord( \"COS\",      COS);\r\n        addKeyWord( \"COT\",      COT);\r\n        addKeyWord( \"DEGREES\",  DEGREES);\r\n        addKeyWord( \"EXP\",      EXP);\r\n        addKeyWord( \"FLOOR\",    FLOOR);\r\n        addKeyWord( \"LOG\",      LOG);\r\n        addKeyWord( \"LOG10\",    LOG10);\r\n        addKeyWord( \"MOD\",      MOD);\r\n        addKeyWord( \"PI\",       PI);\r\n        addKeyWord( \"POWER\",    POWER);\r\n        addKeyWord( \"RADIANS\",  RADIANS);\r\n        addKeyWord( \"RAND\",     RAND);\r\n        addKeyWord( \"ROUND\",    ROUND);\r\n        addKeyWord( \"SIGN\",     SIGN);\r\n        addKeyWord( \"SIN\",      SIN);\r\n        addKeyWord( \"SQRT\",     SQRT);\r\n        addKeyWord( \"TAN\",      TAN);\r\n        addKeyWord( \"TRUNCATE\", TRUNCATE);"
           }

       },

       {
           "id": "clone_232",

           "clone_type": "type-2",

           "origin": {
               "file": "StoreImpl.java",
               "start_line": "735",
               "end_line": "739",
               "source_code": "                    break;\r\n            case SQLTokenizer.INT:\r\n                    writeInt( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.BIGINT:"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "729",
               "end_line": "733",
               "source_code": "                    break;\r\n            case SQLTokenizer.TINYINT:\r\n                    writeByte( expr.getInt() );\r\n                    break;\r\n            case SQLTokenizer.SMALLINT:"
           }

       },

       {
           "id": "clone_233",

           "clone_type": "type-2",

           "origin": {
               "file": "Money.java",
               "start_line": "119",
               "end_line": "126",
               "source_code": "\t\tbytes[offset++] = (byte)(value >> 56);\r\n\t\tbytes[offset++] = (byte)(value >> 48);\r\n\t\tbytes[offset++] = (byte)(value >> 40);\r\n\t\tbytes[offset++] = (byte)(value >> 32);\r\n\t\tbytes[offset++] = (byte)(value >> 24);\r\n\t\tbytes[offset++] = (byte)(value >> 16);\r\n\t\tbytes[offset++] = (byte)(value >> 8);\r\n\t\tbytes[offset++] = (byte)(value);"
           },

           "clone": {
               "file": "StoreImpl.java",
               "start_line": "392",
               "end_line": "399",
               "source_code": "        page[ offset++ ] = (byte)(value >> 56);\r\n        page[ offset++ ] = (byte)(value >> 48);\r\n        page[ offset++ ] = (byte)(value >> 40);\r\n        page[ offset++ ] = (byte)(value >> 32);\r\n        page[ offset++ ] = (byte)(value >> 24);\r\n        page[ offset++ ] = (byte)(value >> 16);\r\n        page[ offset++ ] = (byte)(value >> 8);\r\n        page[ offset++ ] = (byte)(value);"
           }

       }
   ]      
}